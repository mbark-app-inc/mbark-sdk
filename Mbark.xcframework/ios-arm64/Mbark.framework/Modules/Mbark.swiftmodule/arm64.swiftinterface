// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.3.2 (swiftlang-1200.0.45 clang-1200.0.32.28)
// swift-module-flags: -target arm64-apple-ios12.0 -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -module-name Mbark
import Combine
import CoreGraphics
import CoreTelephony
import Dispatch
import Foundation
@_exported import Mbark
import Network
import ObjectiveC
import Security
import Swift
import SystemConfiguration
import UIKit
import os
import ObjectiveC.runtime
@available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Publisher {
  public func toSignal() -> Signal<Self.Output, Self.Failure>
}
@available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Signal {
  public struct CombinePublisher : Combine.Publisher {
    public typealias Output = Element
    public typealias Failure = Error
    public func receive<S>(subscriber: S) where Element == S.Input, Error == S.Failure, S : Combine.Subscriber
  }
  public func toPublisher() -> Signal<Element, Error>.CombinePublisher
}
@available(OSX 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension SignalProtocol {
  public func toPublisher() -> Signal<Self.Element, Self.Error>.CombinePublisher
}
public struct Deferred<DeferredSignal> : SignalProtocol where DeferredSignal : SignalProtocol {
  public init(signalFactory: @escaping () -> DeferredSignal)
  public typealias Element = DeferredSignal.Element
  public typealias Error = DeferredSignal.Error
  public let signalFactory: () -> DeferredSignal
  public func observe(with observer: @escaping (Signal<DeferredSignal.Element, DeferredSignal.Error>.Event) -> Swift.Void) -> Disposable
}
extension Subscribers {
  final public class Accumulator<Input, Failure> : Subscriber, Cancellable where Failure : Swift.Error {
    public init()
    final public var values: [Input] {
      get
    }
    final public var isFinished: Swift.Bool {
      get
    }
    final public var isFailure: Swift.Bool {
      get
    }
    final public var error: Failure? {
      get
    }
    final public func receive(subscription: Subscription)
    final public func receive(_ value: Input) -> Subscribers.Demand
    final public func receive(completion: Subscribers.Completion<Failure>)
    final public func cancel()
    @objc deinit
  }
}
public protocol ReactiveExtensions {
  associatedtype Base
  var base: Self.Base { get }
}
public struct Reactive<Base> : ReactiveExtensions {
  public let base: Base
  public init(_ base: Base)
}
public protocol ReactiveExtensionsProvider : AnyObject {
}
extension ReactiveExtensionsProvider {
  public static var reactive: Reactive<Self>.Type {
    get
  }
  public var reactive: Reactive<Self> {
    get
  }
}
extension NSObject : ReactiveExtensionsProvider {
}
extension ReactiveExtensions where Self.Base : ObjectiveC.NSObject {
  public var deallocated: SafeSignal<Swift.Void> {
    get
  }
  public var bag: DisposeBag {
    get
  }
  public func publisher<Value>(for keyPath: Swift.KeyPath<Self.Base, Value>, options: Foundation.NSKeyValueObservingOptions = [.initial, .new]) -> Signal<Value, Swift.Never>
}
extension SignalProtocol {
  public func subscribe<S>(on scheduler: S) -> Signal<Self.Element, Self.Error> where S : Scheduler
  public func receive<S>(on scheduler: S) -> Signal<Self.Element, Self.Error> where S : Scheduler
}
extension SignalProtocol {
  public func amb<O>(with other: O) -> Signal<Self.Element, Self.Error> where O : SignalProtocol, Self.Element == O.Element, Self.Error == O.Error
  public func amb<O>(with other: O) -> Signal<Self.Element, Self.Error> where O : SignalProtocol, Self.Element == O.Element, O.Error == Swift.Never
  public func combineLatest<O, U>(with other: O, combine: @escaping (Self.Element, O.Element) -> U) -> Signal<U, Self.Error> where O : SignalProtocol, Self.Error == O.Error
  public func combineLatest<O>(with other: O) -> Signal<(Self.Element, O.Element), Self.Error> where O : SignalProtocol, Self.Error == O.Error
  public func combineLatest<O, U>(with other: O, combine: @escaping (Self.Element, O.Element) -> U) -> Signal<U, Self.Error> where O : SignalProtocol, O.Error == Swift.Never
  public func combineLatest<O>(with other: O) -> Signal<(Self.Element, O.Element), Self.Error> where O : SignalProtocol, O.Error == Swift.Never
  public func append<O>(_ other: O) -> Signal<Self.Element, Self.Error> where O : SignalProtocol, Self.Element == O.Element, Self.Error == O.Error
  public func append<O>(_ other: O) -> Signal<Self.Element, Self.Error> where O : SignalProtocol, Self.Element == O.Element, O.Error == Swift.Never
  public func prepend<O>(_ other: O) -> Signal<Self.Element, Self.Error> where O : SignalProtocol, Self.Element == O.Element, Self.Error == O.Error
  public func prepend<O>(_ other: O) -> Signal<Self.Element, Self.Error> where O : SignalProtocol, Self.Element == O.Element, O.Error == Swift.Never
  public func merge<O>(with other: O) -> Signal<Self.Element, Self.Error> where O : SignalProtocol, Self.Element == O.Element, Self.Error == O.Error
  public func merge<O>(with other: O) -> Signal<Self.Element, Self.Error> where O : SignalProtocol, Self.Element == O.Element, O.Error == Swift.Never
  public func replayLatest<S>(when other: S) -> Signal<Self.Element, Self.Error> where S : SignalProtocol, S.Error == Swift.Never
  public func with<O, U>(latestFrom other: O, combine: @escaping (Self.Element, O.Element) -> U) -> Signal<U, Self.Error> where O : SignalProtocol, Self.Error == O.Error
  public func with<O>(latestFrom other: O) -> Signal<(Self.Element, O.Element), Self.Error> where O : SignalProtocol, Self.Error == O.Error
  public func with<O, U>(latestFrom other: O, combine: @escaping (Self.Element, O.Element) -> U) -> Signal<U, Self.Error> where O : SignalProtocol, O.Error == Swift.Never
  public func with<O>(latestFrom other: O) -> Signal<(Self.Element, O.Element), Self.Error> where O : SignalProtocol, O.Error == Swift.Never
  public func zip<O, U>(with other: O, combine: @escaping (Self.Element, O.Element) -> U) -> Signal<U, Self.Error> where O : SignalProtocol, Self.Error == O.Error
  public func zip<O>(with other: O) -> Signal<(Self.Element, O.Element), Self.Error> where O : SignalProtocol, Self.Error == O.Error
  public func zip<O, U>(with other: O, combine: @escaping (Self.Element, O.Element) -> U) -> Signal<U, Self.Error> where O : SignalProtocol, O.Error == Swift.Never
  public func zip<O>(with other: O) -> Signal<(Self.Element, O.Element), Self.Error> where O : SignalProtocol, O.Error == Swift.Never
}
extension SignalProtocol where Self.Error == Swift.Never {
  public func amb<O>(with other: O) -> Signal<Self.Element, O.Error> where O : SignalProtocol, Self.Element == O.Element
  public func combineLatest<O, U>(with other: O, combine: @escaping (Self.Element, O.Element) -> U) -> Signal<U, O.Error> where O : SignalProtocol
  public func combineLatest<O>(with other: O) -> Signal<(Self.Element, O.Element), O.Error> where O : SignalProtocol
  public func append<O>(_ other: O) -> Signal<Self.Element, O.Error> where O : SignalProtocol, Self.Element == O.Element
  public func prepend<O>(_ other: O) -> Signal<Self.Element, O.Error> where O : SignalProtocol, Self.Element == O.Element
  public func merge<O>(with other: O) -> Signal<Self.Element, O.Error> where O : SignalProtocol, Self.Element == O.Element
  public func with<O, U>(latestFrom other: O, combine: @escaping (Self.Element, O.Element) -> U) -> Signal<U, O.Error> where O : SignalProtocol
  public func with<O>(latestFrom other: O) -> Signal<(Self.Element, O.Element), O.Error> where O : SignalProtocol
  public func zip<O, U>(with other: O, combine: @escaping (Self.Element, O.Element) -> U) -> Signal<U, O.Error> where O : SignalProtocol
  public func zip<O>(with other: O) -> Signal<(Self.Element, O.Element), O.Error> where O : SignalProtocol
}
public protocol PropertyProtocol {
  associatedtype ProperyElement
  var value: Self.ProperyElement { get }
}
final public class Property<Value> : PropertyProtocol, SubjectProtocol, BindableProtocol, DisposeBagProvider {
  public init(_ value: Value, subject: Subject<Value, Swift.Never> = PassthroughSubject())
  @objc deinit
  final public var bag: DisposeBag {
    get
  }
  final public var value: Value {
    get
    set
  }
  final public var readOnlyView: AnyProperty<Value> {
    get
  }
  final public func on(_ event: Signal<Value, Swift.Never>.Event)
  final public func observe(with observer: @escaping (Signal<Value, Swift.Never>.Event) -> Swift.Void) -> Disposable
  final public func silentUpdate(value: Value)
  final public func bind(signal: Signal<Value, Swift.Never>) -> Disposable
  public typealias Element = Value
  public typealias Error = Swift.Never
  public typealias ProperyElement = Value
}
final public class AnyProperty<Value> : PropertyProtocol, SignalProtocol {
  public init(property: Property<Value>)
  final public var value: Value {
    get
  }
  final public func observe(with observer: @escaping (Signal<Value, Swift.Never>.Event) -> Swift.Void) -> Disposable
  @objc deinit
  public typealias Element = Value
  public typealias Error = Swift.Never
  public typealias ProperyElement = Value
}
public struct MbarkEventData : Swift.Codable {
  public init(name: Swift.String, value: Swift.String)
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
public protocol ObservableObject : AnyObject {
  associatedtype ObjectWillChangeSignal : SignalProtocol = Signal<Swift.Void, Swift.Never> where Self.ObjectWillChangeSignal.Error == Swift.Never
  var objectWillChange: Self.ObjectWillChangeSignal { get }
}
extension ObservableObject where Self.ObjectWillChangeSignal == Signal<Swift.Void, Swift.Never> {
  public var objectWillChange: Signal<Swift.Void, Swift.Never> {
    get
  }
}
extension NSLock {
  convenience public init(name: Swift.String)
}
extension NSRecursiveLock {
  convenience public init(name: Swift.String)
}
public struct Empty<Element, Error> : SignalProtocol, Swift.Equatable where Error : Swift.Error {
  public init(completeImmediately: Swift.Bool = true)
  public init(completeImmediately: Swift.Bool = true, outputType: Element.Type, failureType: Error.Type)
  public typealias Element = Element
  public typealias Error = Error
  public let completeImmediately: Swift.Bool
  public func observe(with observer: @escaping (Signal<Element, Error>.Event) -> Swift.Void) -> Disposable
  public static func == (a: Empty<Element, Error>, b: Empty<Element, Error>) -> Swift.Bool
}
extension SignalProtocol {
  public func breakpoint(receiveSubscription: (() -> Swift.Bool)? = nil, receiveOutput: ((Self.Element) -> Swift.Bool)? = nil, receiveCompletion: ((Subscribers.Completion<Self.Error>) -> Swift.Bool)? = nil) -> Signal<Self.Element, Self.Error>
  public func breakpointOnError() -> Signal<Self.Element, Self.Error>
  public func debug(_ title: Swift.String? = nil, file: Swift.String = #file, function: Swift.String = #function, line: Swift.Int = #line) -> Signal<Self.Element, Self.Error>
  public func delay(interval: Swift.Double, on queue: Dispatch.DispatchQueue = DispatchQueue(label: "mbark.delay")) -> Signal<Self.Element, Self.Error>
  public func `repeat`<S>(when other: @escaping (Self.Element) -> S) -> Signal<Self.Element, Self.Error> where S : SignalProtocol, S.Error == Swift.Never
  public func handleEvents(receiveSubscription: (() -> Swift.Void)? = nil, receiveOutput: ((Self.Element) -> Swift.Void)? = nil, receiveCompletion: ((Subscribers.Completion<Self.Error>) -> Swift.Void)? = nil, receiveCancel: (() -> Swift.Void)? = nil) -> Signal<Self.Element, Self.Error>
  public func feedActivity<S>(into listener: S) -> Signal<Self.Element, Self.Error> where S : SubjectProtocol, S.Element == Swift.Bool
  public func feedNext<S>(into listener: S) -> Signal<Self.Element, Self.Error> where S : SubjectProtocol, Self.Element == S.Element
  public func feedNext<S>(into listener: S, when: @escaping (Self.Element) -> Swift.Bool = { _ in true }, map: @escaping (Self.Element) -> S.Element) -> Signal<Self.Element, Self.Error> where S : SubjectProtocol
  public func feedError<S>(into listener: S) -> Signal<Self.Element, Self.Error> where S : SubjectProtocol, Self.Error == S.Element
  public func waitAndCollectEvents() -> [Signal<Self.Element, Self.Error>.Event]
  public func waitAndCollectElements() -> [Self.Element]
}
@propertyWrapper public struct Published<Value> {
  public init(wrappedValue: Value)
  public struct Publisher : SignalProtocol {
    public typealias Element = Value
    public typealias Error = Swift.Never
    public func observe(with observer: @escaping (Signal<Value, Swift.Never>.Event) -> Swift.Void) -> Disposable
  }
  public var wrappedValue: Value {
    get
    set
  }
  public var projectedValue: Published<Value>.Publisher {
    mutating get
  }
}
extension CGSize : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public protocol SignalProtocol {
  associatedtype Element
  associatedtype Error : Swift.Error
  func observe(with observer: @escaping Observer<Self.Element, Self.Error>) -> Disposable
}
extension SignalProtocol {
  public func observe<O>(with observer: O) -> Disposable where O : ObserverProtocol, Self.Element == O.Element, Self.Error == O.Error
  public func observeNext(with observer: @escaping (Self.Element) -> Swift.Void) -> Disposable
  public func observeFailed(with observer: @escaping (Self.Error) -> Swift.Void) -> Disposable
  public func observeCompleted(with observer: @escaping () -> Swift.Void) -> Disposable
  public func toSignal() -> Signal<Self.Element, Self.Error>
}
extension SignalProtocol {
  public func sink(receiveCompletion: @escaping ((Subscribers.Completion<Self.Error>) -> Swift.Void), receiveValue: @escaping ((Self.Element) -> Swift.Void)) -> AnyCancellable
}
extension SignalProtocol where Self.Error == Swift.Never {
  public func sink(receiveValue: @escaping ((Self.Element) -> Swift.Void)) -> AnyCancellable
}
extension SignalProtocol where Self.Error == Swift.Never {
  public func assign<Root>(to keyPath: Swift.ReferenceWritableKeyPath<Root, Self.Element>, on object: Root) -> AnyCancellable
}
extension SignalProtocol {
  public func subscribe<Downstream>(_ subscriber: Downstream) where Downstream : Subscriber, Self.Element == Downstream.Input, Self.Error == Downstream.Failure
}
public protocol BindableProtocol {
  associatedtype Element
  func bind(signal: Signal<Self.Element, Swift.Never>) -> Disposable
}
extension SignalProtocol where Self.Error == Swift.Never {
  @discardableResult
  public func bind<B>(to bindable: B) -> Disposable where B : BindableProtocol, Self.Element == B.Element
  @discardableResult
  public func bind<B>(to bindable: B) -> Disposable where B : BindableProtocol, Self.Element == B.Element.Wrapped, B.Element : OptionalProtocol
}
extension BindableProtocol where Self : SignalProtocol, Self.Error == Swift.Never {
  @discardableResult
  public func bidirectionalBind<B>(to target: B) -> Disposable where B : BindableProtocol, B : SignalProtocol, Self.Element == B.Element, B.Error == Swift.Never
}
extension SignalProtocol where Self.Error == Swift.Never {
  @discardableResult
  public func bind<Target>(to target: Target, setter: @escaping (Target, Self.Element) -> Swift.Void) -> Disposable where Target : BindingExecutionContextProvider, Target : Deallocatable
  @discardableResult
  public func bind<Target>(to target: Target, context: ExecutionContext, setter: @escaping (Target, Self.Element) -> Swift.Void) -> Disposable where Target : Deallocatable
  @discardableResult
  public func bind<Target>(to target: Target, keyPath: Swift.ReferenceWritableKeyPath<Target, Self.Element>) -> Disposable where Target : BindingExecutionContextProvider, Target : Deallocatable
  @discardableResult
  public func bind<Target>(to target: Target, keyPath: Swift.ReferenceWritableKeyPath<Target, Self.Element>, context: ExecutionContext) -> Disposable where Target : Deallocatable
}
extension SignalProtocol where Self.Element == Swift.Void, Self.Error == Swift.Never {
  @discardableResult
  public func bind<Target>(to target: Target, setter: @escaping (Target) -> Swift.Void) -> Disposable where Target : BindingExecutionContextProvider, Target : Deallocatable
  @discardableResult
  public func bind<Target>(to target: Target, context: ExecutionContext, setter: @escaping (Target) -> Swift.Void) -> Disposable where Target : Deallocatable
}
public protocol BindingExecutionContextProvider {
  var bindingExecutionContext: ExecutionContext { get }
}
extension SignalProtocol {
  public func mapToResult() -> Signal<Swift.Result<Self.Element, Self.Error>, Swift.Never>
  public func tryMap<U>(_ transform: @escaping (Self.Element) -> Swift.Result<U, Self.Error>) -> Signal<U, Self.Error>
}
extension SignalProtocol where Self.Error == Swift.Never {
  public func tryMap<U, E>(_ transform: @escaping (Self.Element) -> Swift.Result<U, E>) -> Signal<U, E> where E : Swift.Error
}
extension SignalProtocol where Self.Element : _ResultProtocol {
  public func mapValue<NewSuccess>(_ transform: @escaping (Self.Element.Value) -> NewSuccess) -> Signal<Swift.Result<NewSuccess, Self.Element.Error>, Self.Error>
}
extension SignalProtocol where Self.Element : _ResultProtocol, Self.Error == Self.Element.Error {
  public func getValues() -> Signal<Self.Element.Value, Self.Error>
}
extension SignalProtocol where Self.Element : _ResultProtocol, Self.Error == Swift.Never {
  public func getValues() -> Signal<Self.Element.Value, Self.Element.Error>
}
public protocol _ResultProtocol {
  associatedtype Value
  associatedtype Error : Swift.Error
  var _unbox: Swift.Result<Self.Value, Self.Error> { get }
}
extension Result : _ResultProtocol {
  public var _unbox: Swift.Result<Success, Failure> {
    get
  }
  public typealias Value = Success
  public typealias Error = Failure
}
extension Signal {
  public enum Event {
    case next(Element)
    case failed(Error)
    case completed
  }
}
extension Signal.Event {
  public var isNext: Swift.Bool {
    get
  }
  public var isFailed: Swift.Bool {
    get
  }
  public var isCompleted: Swift.Bool {
    get
  }
  public var isTerminal: Swift.Bool {
    get
  }
  public var element: Element? {
    get
  }
  public var error: Error? {
    get
  }
}
extension Signal.Event : Swift.Equatable where Element : Swift.Equatable, Error : Swift.Equatable {
  public static func == (a: Signal<Element, Error>.Event, b: Signal<Element, Error>.Event) -> Swift.Bool
}
public protocol Deallocatable : AnyObject {
  var deallocated: SafeSignal<Swift.Void> { get }
}
public protocol DisposeBagProvider : Deallocatable {
  var bag: DisposeBag { get }
}
extension DisposeBagProvider {
  public var deallocated: SafeSignal<Swift.Void> {
    get
  }
}
extension NSObject : DisposeBagProvider {
  public var bag: DisposeBag {
    get
  }
}
public protocol LoadingStateProtocol {
  associatedtype LoadingValue
  associatedtype LoadingError : Swift.Error
  var asLoadingState: LoadingState<Self.LoadingValue, Self.LoadingError> { get }
}
extension LoadingStateProtocol {
  public var isLoading: Swift.Bool {
    get
  }
  public var value: Self.LoadingValue? {
    get
  }
  public var error: Self.LoadingError? {
    get
  }
}
public enum LoadingState<LoadingValue, LoadingError> : LoadingStateProtocol where LoadingError : Swift.Error {
  case loading
  case loaded(LoadingValue)
  case failed(LoadingError)
  public var asLoadingState: LoadingState<LoadingValue, LoadingError> {
    get
  }
}
public protocol ObservedLoadingStateProtocol : LoadingStateProtocol {
  var asObservedLoadingState: ObservedLoadingState<Self.LoadingValue, Self.LoadingError> { get }
}
extension ObservedLoadingStateProtocol {
  public var isReloading: Swift.Bool {
    get
  }
}
public enum ObservedLoadingState<LoadingValue, LoadingError> : ObservedLoadingStateProtocol where LoadingError : Swift.Error {
  case loading
  case reloading
  case loaded(LoadingValue)
  case failed(LoadingError)
  public var asLoadingState: LoadingState<LoadingValue, LoadingError> {
    get
  }
  public var asObservedLoadingState: ObservedLoadingState<LoadingValue, LoadingError> {
    get
  }
}
extension LoadingState {
  public func isSameStateAs<V, E>(_ other: LoadingState<V, E>) -> Swift.Bool where E : Swift.Error
}
public typealias LoadingSignal<LoadingValue, LoadingError> = SafeSignal<LoadingState<LoadingValue, LoadingError>> where LoadingError : Swift.Error
extension SignalProtocol where Self.Element : LoadingStateProtocol, Self.Error == Swift.Never {
  public typealias LoadingValue = Self.Element.LoadingValue
  public typealias LoadingError = Self.Element.LoadingError
  public static func loading() -> LoadingSignal<Self.LoadingValue, Self.LoadingError>
  public static func loaded(_ value: Self.LoadingValue) -> LoadingSignal<Self.LoadingValue, Self.LoadingError>
  public static func failed(_ error: Self.LoadingError) -> LoadingSignal<Self.LoadingValue, Self.LoadingError>
  public func value() -> SafeSignal<Self.LoadingValue>
  public func mapValue<NewValue>(_ transform: @escaping (Self.LoadingValue) -> NewValue) -> LoadingSignal<NewValue, Self.LoadingError>
  public func mapLoadingError<NewError>(_ transform: @escaping (Self.LoadingError) -> NewError) -> LoadingSignal<Self.LoadingValue, NewError> where NewError : Swift.Error
  public func dematerializeLoadingState() -> Signal<Self.LoadingValue, Self.LoadingError>
  public func liftValue<T>(_ transfrom: @escaping (Signal<Self.LoadingValue, Self.LoadingError>) -> Signal<T, Self.LoadingError>) -> LoadingSignal<T, Self.LoadingError>
  public func liftValue<T>(_ transfrom: @escaping (Signal<Self.LoadingValue, Self.LoadingError>) -> LoadingSignal<T, Self.LoadingError>) -> LoadingSignal<T, Self.LoadingError>
  public func flatMapValue<NewValue>(_ strategy: FlattenStrategy = .latest, transfrom: @escaping (Self.LoadingValue) -> LoadingSignal<NewValue, Self.LoadingError>) -> LoadingSignal<NewValue, Self.LoadingError>
  public func flatMapValue<NewValue>(_ strategy: FlattenStrategy = .latest, transfrom: @escaping (Self.LoadingValue) -> Signal<NewValue, Self.LoadingError>) -> LoadingSignal<NewValue, Self.LoadingError>
  public func deriveObservedLoadingState(loadsAgainOnFailure: Swift.Bool = true) -> Signal<ObservedLoadingState<Self.LoadingValue, Self.LoadingError>, Swift.Never>
}
extension SignalProtocol {
  public func toLoadingSignal() -> LoadingSignal<Self.Element, Self.Error>
}
public protocol LoadingStateListener : AnyObject {
  func setLoadingState<LoadingValue, LoadingError>(_ state: ObservedLoadingState<LoadingValue, LoadingError>) where LoadingError : Swift.Error
  var loadingStateListenerNeedsWeakReference: Swift.Bool { get }
}
extension LoadingStateListener {
  public var loadingStateListenerNeedsWeakReference: Swift.Bool {
    get
  }
}
extension SignalProtocol where Self.Element : ObservedLoadingStateProtocol, Self.Error == Swift.Never {
  public func updateLoadingState(of listener: BindingExecutionContextProvider & LoadingStateListener) -> Signal<ObservedLoadingState<Self.LoadingValue, Self.LoadingError>, Swift.Never>
  public func updateLoadingState(of listener: LoadingStateListener, context: ExecutionContext) -> Signal<ObservedLoadingState<Self.LoadingValue, Self.LoadingError>, Swift.Never>
  public func consumeLoadingState(by listener: BindingExecutionContextProvider & LoadingStateListener) -> SafeSignal<Self.LoadingValue>
  public func consumeLoadingState(by listener: LoadingStateListener, context: ExecutionContext) -> SafeSignal<Self.LoadingValue>
}
extension SignalProtocol where Self.Element : LoadingStateProtocol, Self.Error == Swift.Never {
  public func updateLoadingState(of listener: BindingExecutionContextProvider & LoadingStateListener) -> LoadingSignal<Self.LoadingValue, Self.LoadingError>
  public func updateLoadingState(of listener: LoadingStateListener, context: ExecutionContext) -> LoadingSignal<Self.LoadingValue, Self.LoadingError>
  public func consumeLoadingState(by listener: BindingExecutionContextProvider & LoadingStateListener) -> SafeSignal<Self.LoadingValue>
  public func consumeLoadingState(by listener: LoadingStateListener, context: ExecutionContext) -> SafeSignal<Self.LoadingValue>
}
public enum TimelaneLaneType : Swift.Int, Swift.CaseIterable {
  case subscription, event
  public typealias RawValue = Swift.Int
  public init?(rawValue: Swift.Int)
  public var rawValue: Swift.Int {
    get
  }
  public typealias AllCases = [TimelaneLaneType]
  public static var allCases: [TimelaneLaneType] {
    get
  }
}
extension SignalProtocol {
  public func laneIfAvailable(_ name: Swift.String, filter: Swift.Set<TimelaneLaneType> = Set(TimelaneLaneType.allCases), file: Swift.StaticString = #file, function: Swift.StaticString = #function, line: Swift.UInt = #line) -> Signal<Self.Element, Self.Error>
  @available(OSX 10.14, iOS 12, tvOS 12, watchOS 5, *)
  public func lane(_ name: Swift.String, filter: Swift.Set<TimelaneLaneType> = Set(TimelaneLaneType.allCases), file: Swift.StaticString = #file, function: Swift.StaticString = #function, line: Swift.UInt = #line) -> Signal<Self.Element, Self.Error>
}
public enum MbarkEventType : Swift.String {
  case accept
  case background
  case flowStart
  case flowEnd
  case input
  case longPress
  case reject
  case swipeLeft
  case swipeRight
  case tap
  case view
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
  public init?(rawValue: Swift.String)
}
public protocol Scheduler {
  func schedule(_ action: @escaping () -> Swift.Void)
}
extension ExecutionContext : Scheduler {
  public func schedule(_ action: @escaping () -> Swift.Void)
}
extension DispatchQueue : Scheduler {
  public func schedule(_ action: @escaping () -> Swift.Void)
}
@available(*, deprecated, message: "Event<Element, Error> has been renamed to Signal<Element, Error>.Event")
public typealias Event<Element, Error> = Signal<Element, Error>.Event where Error : Swift.Error
@available(*, deprecated, renamed: "Never")
public typealias NoError = Swift.Never
@available(*, deprecated, renamed: "SafeSignal")
public typealias Signal1<Element> = Signal<Element, Swift.Never>
@available(*, deprecated, renamed: "SafeObserver")
public typealias Observer1<Element> = (Event<Element, Swift.Never>) -> Swift.Void
@available(*, deprecated, renamed: "SafePublishSubject")
public typealias PublishSubject1<Element> = PublishSubject<Element, Swift.Never>
@available(*, deprecated, renamed: "SafeReplaySubject")
public typealias ReplaySubject1<Element> = ReplaySubject<Element, Swift.Never>
@available(*, deprecated, renamed: "SafeReplayOneSubject")
public typealias ReplayOneSubject1<Element> = ReplayOneSubject<Element, Swift.Never>
extension SignalProtocol {
  @available(*, deprecated, renamed: "init(just:)")
  public static func just(_ element: Self.Element) -> Signal<Self.Element, Self.Error>
  @available(*, deprecated, renamed: "init(sequence:)")
  public static func sequence<S>(_ sequence: S) -> Signal<Self.Element, Self.Error> where S : Swift.Sequence, Self.Element == S.Element
  @available(*, deprecated, message: "Please use Signal(sequence: 0..., interval: N) instead")
  public static func interval(_ interval: Swift.Double, queue: Dispatch.DispatchQueue = DispatchQueue(label: "com.reactivekit.interval")) -> Signal<Swift.Int, Self.Error>
  @available(*, deprecated, message: "Please use Signal(just:after:) instead")
  public static func timer(element: Self.Element, time: Swift.Double, queue: Dispatch.DispatchQueue = DispatchQueue(label: "com.reactivekit.timer")) -> Signal<Self.Element, Self.Error>
}
@available(*, deprecated, message: "Please use Signal(flattening: signals, strategy: .merge")
public func merge<Element, Error>(_ signals: [Signal<Element, Error>]) -> Signal<Element, Error> where Error : Swift.Error
@available(*, deprecated, renamed: "Signal(combiningLatest:combine:)")
public func combineLatest<Element, Result, Error>(_ signals: [Signal<Element, Error>], combine: @escaping ([Element]) -> Result) -> Signal<Result, Error> where Error : Swift.Error
extension SignalProtocol where Self.Element : OptionalProtocol {
  @available(*, deprecated, renamed: "replaceNils")
  public func replaceNil(with replacement: Self.Element.Wrapped) -> Signal<Self.Element.Wrapped, Self.Error>
  @available(*, deprecated, renamed: "ignoreNils")
  public func ignoreNil() -> Signal<Self.Element.Wrapped, Self.Error>
}
extension Signal where Error == Swift.Never {
  @available(*, deprecated, message: "Replace with compactMap { $0.element }`")
  public func elements<U, E>() -> Signal<U, Swift.Never> where Element == Signal<U, E>.Event, E : Swift.Error
  @available(*, deprecated, message: "Replace with compactMap { $0.error }`")
  public func errors<U, E>() -> Signal<E, Swift.Never> where Element == Signal<U, E>.Event, E : Swift.Error
}
extension SignalProtocol {
  @available(*, deprecated, renamed: "debounce(interval:queue:)")
  public func debounce(interval: Swift.Double, on queue: Dispatch.DispatchQueue) -> Signal<Self.Element, Self.Error>
  @available(*, deprecated, renamed: "distinctUntilChanged")
  public func distinct(areDistinct: @escaping (Self.Element, Self.Element) -> Swift.Bool) -> Signal<Self.Element, Self.Error>
  @available(*, deprecated, renamed: "replaceElements")
  public func replace<T>(with element: T) -> Signal<T, Self.Error>
}
extension SignalProtocol where Self.Element : Swift.Equatable {
  @available(*, deprecated, renamed: "distinctUntilChanged")
  public func distinct() -> Signal<Self.Element, Self.Error>
}
extension SignalProtocol where Self.Element : Swift.Sequence {
  @available(*, deprecated, renamed: "flattenElements")
  public func unwrap() -> Signal<Self.Element.Iterator.Element, Self.Error>
}
@_inheritsConvenienceInitializers @available(*, deprecated, renamed: "PassthroughSubject")
final public class PublishSubject<Element, Error> : Subject<Element, Error> where Error : Swift.Error {
  @objc deinit
  override public init()
}
@available(*, deprecated, renamed: "PassthroughSubject")
public typealias SafePublishSubject<Element> = PublishSubject<Element, Swift.Never>
extension ObserverProtocol {
  @available(*, deprecated, renamed: "receive(_:)")
  public func next(_ element: Self.Element)
  @available(*, deprecated, message: "Please use receive(completion: .failure(error))")
  public func failed(_ error: Self.Error)
  @available(*, deprecated, message: "Please use receive(completion: .finished)")
  public func completed()
  @available(*, deprecated, renamed: "receive(lastElement:)")
  public func completed(with element: Self.Element)
}
extension ObserverProtocol where Self.Element == Swift.Void {
  @available(*, deprecated, renamed: "receive")
  public func next()
}
extension SubjectProtocol {
  @available(*, deprecated, renamed: "send(_:)")
  public func next(_ element: Self.Element)
  @available(*, deprecated, message: "Please use send(completion: .failure(error))")
  public func failed(_ error: Self.Error)
  @available(*, deprecated, message: "Please use send(completion: .finished)")
  public func completed()
  @available(*, deprecated, renamed: "send(lastElement:)")
  public func completed(with element: Self.Element)
}
extension SubjectProtocol where Self.Element == Swift.Void {
  @available(*, deprecated, renamed: "send")
  public func next()
}
extension Subject {
  @available(*, deprecated, renamed: "receive(event:)")
  open func send(_ event: Event<Element, Error>)
}
extension SignalProtocol {
  @available(*, deprecated, renamed: "share(limit:)")
  public func shareReplay(limit: Swift.Int = Int.max) -> Signal<Self.Element, Self.Error>
}
extension SignalProtocol {
  @available(*, deprecated, renamed: "subscribe(on:)")
  public func executeIn(_ context: ExecutionContext) -> Signal<Self.Element, Self.Error>
  @available(*, deprecated, renamed: "subscribe(on:)")
  public func executeOn(_ queue: Dispatch.DispatchQueue) -> Signal<Self.Element, Self.Error>
  @available(*, deprecated, renamed: "receive(on:)")
  public func observeIn(_ context: ExecutionContext) -> Signal<Self.Element, Self.Error>
  @available(*, deprecated, renamed: "receive(on:)")
  public func observeOn(_ queue: Dispatch.DispatchQueue) -> Signal<Self.Element, Self.Error>
}
extension SignalProtocol {
  @available(*, deprecated, message: "Please use `removeDuplicates(by:)` instead, but note that the closure should now return `true` when the element are equal!")
  public func distinctUntilChanged(_ areDistinct: @escaping (Self.Element, Self.Element) -> Swift.Bool) -> Signal<Self.Element, Self.Error>
  @available(*, deprecated, renamed: "debounce(for:queue:)")
  public func debounce(interval: Swift.Double, queue: Dispatch.DispatchQueue = DispatchQueue(label: "com.mbark.signal.debounce")) -> Signal<Self.Element, Self.Error>
  @available(*, deprecated, renamed: "output(at:)")
  public func element(at index: Swift.Int) -> Signal<Self.Element, Self.Error>
  @available(*, deprecated, renamed: "dropFirst(_:)")
  public func skip(first count: Swift.Int) -> Signal<Self.Element, Self.Error>
  @available(*, deprecated, renamed: "dropLast(_:)")
  public func skip(last count: Swift.Int) -> Signal<Self.Element, Self.Error>
  @available(*, deprecated, renamed: "dropFirst(for:)")
  public func skip(interval: Swift.Double) -> Signal<Self.Element, Self.Error>
  @available(*, deprecated, renamed: "prefix(while:)")
  public func take(while shouldContinue: @escaping (Self.Element) -> Swift.Bool) -> Signal<Self.Element, Self.Error>
  @available(*, deprecated, renamed: "prefix(untilOutputFrom:)")
  public func take<S>(until signal: S) -> Signal<Self.Element, Self.Error> where S : SignalProtocol
  @available(*, deprecated, renamed: "prefix(maxLength:)")
  public func take(first count: Swift.Int) -> Signal<Self.Element, Self.Error>
  @available(*, deprecated, renamed: "suffix(maxLength:)")
  public func take(last count: Swift.Int) -> Signal<Self.Element, Self.Error>
  @available(*, deprecated, renamed: "throttle(for:)")
  public func throttle(seconds: Swift.Double) -> Signal<Self.Element, Self.Error>
}
extension SignalProtocol where Self.Element : Swift.Equatable {
  @available(*, deprecated, renamed: "removeDuplicates")
  public func distinctUntilChanged() -> Signal<Self.Element, Self.Error>
}
extension SignalProtocol {
  @available(*, deprecated, renamed: "buffer(size:)")
  public func buffer(ofSize size: Swift.Int) -> Signal<[Self.Element], Self.Error>
  @available(*, deprecated, renamed: "replaceEmpty(with:)")
  public func defaultIfEmpty(_ element: Self.Element) -> Signal<Self.Element, Self.Error>
  @available(*, deprecated, renamed: "prepend(_:)")
  public func start(with element: Self.Element) -> Signal<Self.Element, Self.Error>
  @available(*, deprecated, renamed: "ignoreOutput")
  public func ignoreElements() -> Signal<Self.Element, Self.Error>
  @available(*, deprecated, renamed: "replaceError(with:)")
  public func recover(with element: Self.Element) -> Signal<Self.Element, Swift.Never>
  @available(*, deprecated, renamed: "retry(_:)")
  public func retry(times: Swift.Int) -> Signal<Self.Element, Self.Error>
  @available(*, deprecated, renamed: "handleEvents(receiveSubscription:receiveOutput:receiveCompletion:receiveCancel:)")
  public func doOn(next: ((Self.Element) -> Swift.Void)? = nil, start: (() -> Swift.Void)? = nil, failed: ((Self.Error) -> Swift.Void)? = nil, completed: (() -> Swift.Void)? = nil, disposed: (() -> Swift.Void)? = nil) -> Signal<Self.Element, Self.Error>
}
extension SignalProtocol {
  @available(*, deprecated, renamed: "append(_:)")
  public func concat<O>(with other: O) -> Signal<Self.Element, Self.Error> where O : SignalProtocol, Self.Element == O.Element, Self.Error == O.Error
  @available(*, deprecated, renamed: "append(_:)")
  public func concat<O>(with other: O) -> Signal<Self.Element, Self.Error> where O : SignalProtocol, Self.Element == O.Element, O.Error == Swift.Never
}
extension SignalProtocol where Self.Error == Swift.Never {
  @available(*, deprecated, renamed: "append(_:)")
  public func concat<O>(with other: O) -> Signal<Self.Element, O.Error> where O : SignalProtocol, Self.Element == O.Element
}
extension SignalProtocol {
  @available(*, deprecated, message: "Please provide `receiveCompletion` argument when observing signals with error type other than `Never`.")
  public func sink(receiveValue: @escaping ((Self.Element) -> Swift.Void)) -> AnyCancellable
}
public protocol Subscriber {
  associatedtype Input
  associatedtype Failure : Swift.Error
  func receive(subscription: Subscription)
  func receive(_ input: Self.Input) -> Subscribers.Demand
  func receive(completion: Subscribers.Completion<Self.Failure>)
}
extension Subscriber where Self.Input == Swift.Void {
  public func receive() -> Subscribers.Demand
}
public protocol Cancellable {
  func cancel()
}
public protocol ConnectableSignalProtocol : SignalProtocol {
  func connect() -> Disposable
}
final public class ConnectableSignal<Source> : ConnectableSignalProtocol where Source : SignalProtocol {
  public init(source: Source, subject: Subject<Source.Element, Source.Error>)
  final public func connect() -> Disposable
  final public func observe(with observer: @escaping (Signal<Source.Element, Source.Error>.Event) -> Swift.Void) -> Disposable
  @objc deinit
  public typealias Element = Source.Element
  public typealias Error = Source.Error
}
extension ConnectableSignalProtocol {
  public func refCount(disconnectCount: Swift.Int = 0) -> Signal<Self.Element, Self.Error>
}
extension SignalProtocol {
  public func multicast(_ createSubject: () -> Subject<Self.Element, Self.Error>) -> ConnectableSignal<Self>
  public func multicast(subject: Subject<Self.Element, Self.Error>) -> ConnectableSignal<Self>
  public func replay(limit: Swift.Int = Int.max) -> ConnectableSignal<Self>
  public func publish() -> ConnectableSignal<Self>
  public func share(limit: Swift.Int = Int.max, keepAlive: Swift.Bool = false) -> Signal<Self.Element, Self.Error>
}
extension SignalProtocol where Self.Element : LoadingStateProtocol {
  public func replayValues(limit: Swift.Int = Int.max) -> ConnectableSignal<Signal<LoadingState<Self.Element.LoadingValue, Self.Element.LoadingError>, Self.Error>>
  public func shareReplayValues(limit: Swift.Int = Int.max) -> Signal<LoadingState<Self.Element.LoadingValue, Self.Element.LoadingError>, Self.Error>
}
extension SignalProtocol {
  public func debounce(for seconds: Swift.Double, queue: Dispatch.DispatchQueue = DispatchQueue(label: "com.mbark.signal.debounce")) -> Signal<Self.Element, Self.Error>
  public func removeDuplicates(by areEqual: @escaping (Self.Element, Self.Element) -> Swift.Bool) -> Signal<Self.Element, Self.Error>
  public func output(at index: Swift.Int) -> Signal<Self.Element, Self.Error>
  public func filter(_ isIncluded: @escaping (Self.Element) -> Swift.Bool) -> Signal<Self.Element, Self.Error>
  public func flatMapFilter(_ strategy: FlattenStrategy = .concat, _ isIncluded: @escaping (Self.Element) -> SafeSignal<Swift.Bool>) -> Signal<Self.Element, Self.Error>
  public func first() -> Signal<Self.Element, Self.Error>
  public func ignoreOutput() -> Signal<Self.Element, Self.Error>
  public func ignoreTerminal() -> Signal<Self.Element, Self.Error>
  public func last() -> Signal<Self.Element, Self.Error>
  public func pausable<O>(by other: O) -> Signal<Self.Element, Self.Error> where O : SignalProtocol, O.Element == Swift.Bool
  public func sample(interval: Swift.Double, on queue: Dispatch.DispatchQueue = DispatchQueue(label: "com.mbark.signal.sample")) -> Signal<Self.Element, Self.Error>
  public func dropFirst(_ count: Swift.Int) -> Signal<Self.Element, Self.Error>
  public func dropLast(_ count: Swift.Int) -> Signal<Self.Element, Self.Error>
  public func dropFirst(for seconds: Swift.Double) -> Signal<Self.Element, Self.Error>
  public func prefix(maxLength: Swift.Int) -> Signal<Self.Element, Self.Error>
  public func suffix(maxLength: Swift.Int) -> Signal<Self.Element, Self.Error>
  public func prefix(while shouldContinue: @escaping (Self.Element) -> Swift.Bool, inclusive: Swift.Bool = false) -> Signal<Self.Element, Self.Error>
  public func prefix<S>(untilOutputFrom signal: S) -> Signal<Self.Element, Self.Error> where S : SignalProtocol
  public func throttle(for seconds: Swift.Double) -> Signal<Self.Element, Self.Error>
}
extension SignalProtocol where Self.Element : Swift.Equatable {
  public func removeDuplicates() -> Signal<Self.Element, Self.Error>
}
extension SignalProtocol {
  public func compactMap<NewWrapped>(_ transform: @escaping (Self.Element) -> NewWrapped?) -> Signal<NewWrapped, Self.Error>
}
extension SignalProtocol where Self.Element : OptionalProtocol {
  public func mapWrapped<NewWrapped>(_ transform: @escaping (Self.Element.Wrapped) -> NewWrapped) -> Signal<NewWrapped?, Self.Error>
  public func replaceNils(with replacement: Self.Element.Wrapped) -> Signal<Self.Element.Wrapped, Self.Error>
  public func ignoreNils() -> Signal<Self.Element.Wrapped, Self.Error>
}
public protocol OptionalProtocol {
  associatedtype Wrapped
  var _unbox: Swift.Optional<Self.Wrapped> { get }
  init(nilLiteral: ())
  init(_ some: Self.Wrapped)
}
extension Optional : OptionalProtocol {
  public var _unbox: Swift.Optional<Wrapped> {
    get
  }
}
public protocol Disposable : Cancellable {
  func dispose()
  var isDisposed: Swift.Bool { get }
}
extension Disposable {
  public func cancel()
}
public struct NonDisposable : Disposable {
  public static let instance: NonDisposable
  public func dispose()
  public var isDisposed: Swift.Bool {
    get
  }
}
final public class SimpleDisposable : Disposable {
  public init(isDisposed: Swift.Bool = false)
  final public var isDisposed: Swift.Bool {
    get
    set
  }
  final public func dispose()
  @objc deinit
}
final public class BlockDisposable : Disposable {
  public init(_ handler: @escaping () -> Swift.Void)
  final public var isDisposed: Swift.Bool {
    get
  }
  final public func dispose()
  @objc deinit
}
final public class DeinitDisposable : Disposable {
  public init(disposable: Disposable)
  @objc deinit
  final public var otherDisposable: Disposable? {
    get
    set
  }
  final public var isDisposed: Swift.Bool {
    get
  }
  final public func dispose()
}
final public class CompositeDisposable : Disposable {
  public init()
  public init(_ disposables: [Disposable])
  final public var isDisposed: Swift.Bool {
    get
  }
  public static func += (left: CompositeDisposable, right: Disposable)
  final public func add(disposable: Disposable)
  final public func dispose()
  @objc deinit
}
final public class SerialDisposable : Disposable {
  public init(otherDisposable: Disposable?)
  final public var isDisposed: Swift.Bool {
    get
  }
  final public var otherDisposable: Disposable? {
    get
    set
  }
  final public func dispose()
  @objc deinit
}
public protocol DisposeBagProtocol : Disposable {
  func add(disposable: Disposable)
}
final public class DisposeBag : DisposeBagProtocol {
  public init()
  @objc deinit
  final public var isDisposed: Swift.Bool {
    get
  }
  final public var deallocated: SafeSignal<Swift.Void> {
    get
  }
  public static func += (left: DisposeBag, right: Disposable)
  public static func += (left: DisposeBag, right: [Disposable])
  final public func add(disposable: Disposable)
  final public func add(disposables: [Disposable])
  final public func dispose()
}
final public class AnyCancellable : Disposable {
  public init(_ handler: @escaping () -> Swift.Void)
  @objc deinit
  final public var isDisposed: Swift.Bool {
    get
  }
  final public func dispose()
}
extension AnyCancellable : Swift.Hashable {
  public static func == (lhs: AnyCancellable, rhs: AnyCancellable) -> Swift.Bool
  final public func hash(into hasher: inout Swift.Hasher)
  final public var hashValue: Swift.Int {
    get
  }
}
extension AnyCancellable {
  convenience public init(_ disposable: Disposable)
  final public func store<C>(in collection: inout C) where C : Swift.RangeReplaceableCollection, C.Element == AnyCancellable
  final public func store(in set: inout Swift.Set<AnyCancellable>)
}
extension Disposable {
  public func dispose(in disposeBag: DisposeBagProtocol)
  public func store(in disposeBag: DisposeBagProtocol)
  public func store<C>(in collection: inout C) where C : Swift.RangeReplaceableCollection, C.Element == AnyCancellable
  public func store(in set: inout Swift.Set<AnyCancellable>)
}
public func combineLatest<A, B, Result>(_ a: A, _ b: B, combine: @escaping (A.Element, B.Element) -> Result) -> Signal<Result, A.Error> where A : SignalProtocol, B : SignalProtocol, A.Error == B.Error
public func combineLatest<A, B, C, Result>(_ a: A, _ b: B, _ c: C, combine: @escaping (A.Element, B.Element, C.Element) -> Result) -> Signal<Result, A.Error> where A : SignalProtocol, B : SignalProtocol, C : SignalProtocol, A.Error == B.Error, B.Error == C.Error
public func combineLatest<A, B, C, D, Result>(_ a: A, _ b: B, _ c: C, _ d: D, combine: @escaping (A.Element, B.Element, C.Element, D.Element) -> Result) -> Signal<Result, A.Error> where A : SignalProtocol, B : SignalProtocol, C : SignalProtocol, D : SignalProtocol, A.Error == B.Error, B.Error == C.Error, C.Error == D.Error
public func combineLatest<A, B, C, D, E, Result>(_ a: A, _ b: B, _ c: C, _ d: D, _ e: E, combine: @escaping (A.Element, B.Element, C.Element, D.Element, E.Element) -> Result) -> Signal<Result, A.Error> where A : SignalProtocol, B : SignalProtocol, C : SignalProtocol, D : SignalProtocol, E : SignalProtocol, A.Error == B.Error, B.Error == C.Error, C.Error == D.Error, D.Error == E.Error
public func combineLatest<A, B, C, D, E, F, Result>(_ a: A, _ b: B, _ c: C, _ d: D, _ e: E, _ f: F, combine: @escaping (A.Element, B.Element, C.Element, D.Element, E.Element, F.Element) -> Result) -> Signal<Result, A.Error> where A : SignalProtocol, B : SignalProtocol, C : SignalProtocol, D : SignalProtocol, E : SignalProtocol, F : SignalProtocol, A.Error == B.Error, B.Error == C.Error, C.Error == D.Error, D.Error == E.Error, E.Error == F.Error
public func combineLatest<A, B>(_ a: A, _ b: B) -> Signal<(A.Element, B.Element), A.Error> where A : SignalProtocol, B : SignalProtocol, A.Error == B.Error
public func combineLatest<A, B, C>(_ a: A, _ b: B, _ c: C) -> Signal<(A.Element, B.Element, C.Element), A.Error> where A : SignalProtocol, B : SignalProtocol, C : SignalProtocol, A.Error == B.Error, B.Error == C.Error
public func combineLatest<A, B, C, D>(_ a: A, _ b: B, _ c: C, _ d: D) -> Signal<(A.Element, B.Element, C.Element, D.Element), A.Error> where A : SignalProtocol, B : SignalProtocol, C : SignalProtocol, D : SignalProtocol, A.Error == B.Error, B.Error == C.Error, C.Error == D.Error
public func combineLatest<A, B, C, D, E>(_ a: A, _ b: B, _ c: C, _ d: D, _ e: E) -> Signal<(A.Element, B.Element, C.Element, D.Element, E.Element), A.Error> where A : SignalProtocol, B : SignalProtocol, C : SignalProtocol, D : SignalProtocol, E : SignalProtocol, A.Error == B.Error, B.Error == C.Error, C.Error == D.Error, D.Error == E.Error
public func combineLatest<A, B, C, D, E, F>(_ a: A, _ b: B, _ c: C, _ d: D, _ e: E, _ f: F) -> Signal<(A.Element, B.Element, C.Element, D.Element, E.Element, F.Element), A.Error> where A : SignalProtocol, B : SignalProtocol, C : SignalProtocol, D : SignalProtocol, E : SignalProtocol, F : SignalProtocol, A.Error == B.Error, B.Error == C.Error, C.Error == D.Error, D.Error == E.Error, E.Error == F.Error
public func zip<A, B, Result>(_ a: A, _ b: B, combine: @escaping (A.Element, B.Element) -> Result) -> Signal<Result, A.Error> where A : SignalProtocol, B : SignalProtocol, A.Error == B.Error
public func zip<A, B, C, Result>(_ a: A, _ b: B, _ c: C, combine: @escaping (A.Element, B.Element, C.Element) -> Result) -> Signal<Result, A.Error> where A : SignalProtocol, B : SignalProtocol, C : SignalProtocol, A.Error == B.Error, B.Error == C.Error
public func zip<A, B, C, D, Result>(_ a: A, _ b: B, _ c: C, _ d: D, combine: @escaping (A.Element, B.Element, C.Element, D.Element) -> Result) -> Signal<Result, A.Error> where A : SignalProtocol, B : SignalProtocol, C : SignalProtocol, D : SignalProtocol, A.Error == B.Error, B.Error == C.Error, C.Error == D.Error
public func zip<A, B, C, D, E, Result>(_ a: A, _ b: B, _ c: C, _ d: D, _ e: E, combine: @escaping (A.Element, B.Element, C.Element, D.Element, E.Element) -> Result) -> Signal<Result, A.Error> where A : SignalProtocol, B : SignalProtocol, C : SignalProtocol, D : SignalProtocol, E : SignalProtocol, A.Error == B.Error, B.Error == C.Error, C.Error == D.Error, D.Error == E.Error
public func zip<A, B, C, D, E, F, Result>(_ a: A, _ b: B, _ c: C, _ d: D, _ e: E, _ f: F, combine: @escaping (A.Element, B.Element, C.Element, D.Element, E.Element, F.Element) -> Result) -> Signal<Result, A.Error> where A : SignalProtocol, B : SignalProtocol, C : SignalProtocol, D : SignalProtocol, E : SignalProtocol, F : SignalProtocol, A.Error == B.Error, B.Error == C.Error, C.Error == D.Error, D.Error == E.Error, E.Error == F.Error
public func zip<A, B>(_ a: A, _ b: B) -> Signal<(A.Element, B.Element), A.Error> where A : SignalProtocol, B : SignalProtocol, A.Error == B.Error
public func zip<A, B, C>(_ a: A, _ b: B, _ c: C) -> Signal<(A.Element, B.Element, C.Element), A.Error> where A : SignalProtocol, B : SignalProtocol, C : SignalProtocol, A.Error == B.Error, B.Error == C.Error
public func zip<A, B, C, D>(_ a: A, _ b: B, _ c: C, _ d: D) -> Signal<(A.Element, B.Element, C.Element, D.Element), A.Error> where A : SignalProtocol, B : SignalProtocol, C : SignalProtocol, D : SignalProtocol, A.Error == B.Error, B.Error == C.Error, C.Error == D.Error
public func zip<A, B, C, D, E>(_ a: A, _ b: B, _ c: C, _ d: D, _ e: E) -> Signal<(A.Element, B.Element, C.Element, D.Element, E.Element), A.Error> where A : SignalProtocol, B : SignalProtocol, C : SignalProtocol, D : SignalProtocol, E : SignalProtocol, A.Error == B.Error, B.Error == C.Error, C.Error == D.Error, D.Error == E.Error
public func zip<A, B, C, D, E, F>(_ a: A, _ b: B, _ c: C, _ d: D, _ e: E, _ f: F) -> Signal<(A.Element, B.Element, C.Element, D.Element, E.Element, F.Element), A.Error> where A : SignalProtocol, B : SignalProtocol, C : SignalProtocol, D : SignalProtocol, E : SignalProtocol, F : SignalProtocol, A.Error == B.Error, B.Error == C.Error, C.Error == D.Error, D.Error == E.Error, E.Error == F.Error
public func merge<A, B>(_ a: A, _ b: B) -> Signal<A.Element, A.Error> where A : SignalProtocol, B : SignalProtocol, A.Element == B.Element, A.Error == B.Error
public func merge<A, B, C>(_ a: A, _ b: B, _ c: C) -> Signal<A.Element, A.Error> where A : SignalProtocol, B : SignalProtocol, C : SignalProtocol, A.Element == B.Element, A.Error == B.Error, B.Element == C.Element, B.Error == C.Error
public func merge<A, B, C, D>(_ a: A, _ b: B, _ c: C, _ d: D) -> Signal<A.Element, A.Error> where A : SignalProtocol, B : SignalProtocol, C : SignalProtocol, D : SignalProtocol, A.Element == B.Element, A.Error == B.Error, B.Element == C.Element, B.Error == C.Error, C.Element == D.Element, C.Error == D.Error
public func merge<A, B, C, D, E>(_ a: A, _ b: B, _ c: C, _ d: D, _ e: E) -> Signal<A.Element, A.Error> where A : SignalProtocol, B : SignalProtocol, C : SignalProtocol, D : SignalProtocol, E : SignalProtocol, A.Element == B.Element, A.Error == B.Error, B.Element == C.Element, B.Error == C.Error, C.Element == D.Element, C.Error == D.Error, D.Element == E.Element, D.Error == E.Error
public func merge<A, B, C, D, E, F>(_ a: A, _ b: B, _ c: C, _ d: D, _ e: E, _ f: F) -> Signal<A.Element, A.Error> where A : SignalProtocol, B : SignalProtocol, C : SignalProtocol, D : SignalProtocol, E : SignalProtocol, F : SignalProtocol, A.Element == B.Element, A.Error == B.Error, B.Element == C.Element, B.Error == C.Error, C.Element == D.Element, C.Error == D.Error, D.Element == E.Element, D.Error == E.Error, E.Element == F.Element, E.Error == F.Error
public func amb<A, B>(_ a: A, _ b: B) -> Signal<A.Element, A.Error> where A : SignalProtocol, B : SignalProtocol, A.Element == B.Element, A.Error == B.Error
public func amb<A, B, C>(_ a: A, _ b: B, _ c: C) -> Signal<A.Element, A.Error> where A : SignalProtocol, B : SignalProtocol, C : SignalProtocol, A.Element == B.Element, A.Error == B.Error, B.Element == C.Element, B.Error == C.Error
public func amb<A, B, C, D>(_ a: A, _ b: B, _ c: C, _ d: D) -> Signal<A.Element, A.Error> where A : SignalProtocol, B : SignalProtocol, C : SignalProtocol, D : SignalProtocol, A.Element == B.Element, A.Error == B.Error, B.Element == C.Element, B.Error == C.Error, C.Element == D.Element, C.Error == D.Error
public func amb<A, B, C, D, E>(_ a: A, _ b: B, _ c: C, _ d: D, _ e: E) -> Signal<A.Element, A.Error> where A : SignalProtocol, B : SignalProtocol, C : SignalProtocol, D : SignalProtocol, E : SignalProtocol, A.Element == B.Element, A.Error == B.Error, B.Element == C.Element, B.Error == C.Error, C.Element == D.Element, C.Error == D.Error, D.Element == E.Element, D.Error == E.Error
public func amb<A, B, C, D, E, F>(_ a: A, _ b: B, _ c: C, _ d: D, _ e: E, _ f: F) -> Signal<A.Element, A.Error> where A : SignalProtocol, B : SignalProtocol, C : SignalProtocol, D : SignalProtocol, E : SignalProtocol, F : SignalProtocol, A.Element == B.Element, A.Error == B.Error, B.Element == C.Element, B.Error == C.Error, C.Element == D.Element, C.Error == D.Error, D.Element == E.Element, D.Error == E.Error, E.Element == F.Element, E.Error == F.Error
public struct Signal<Element, Error> : SignalProtocol where Error : Swift.Error {
  public typealias Producer = (AtomicObserver<Element, Error>) -> Disposable
  public init(_ producer: @escaping Signal<Element, Error>.Producer)
  public func observe(with observer: @escaping Observer<Element, Error>) -> Disposable
}
public typealias SafeSignal<Element> = Signal<Element, Swift.Never>
extension Signal {
  public static func completed() -> Signal<Element, Error>
  public static func failed(_ error: Error) -> Signal<Element, Error>
  public static func never() -> Signal<Element, Error>
  public static func withObserver() -> (Signal<Element, Error>, AnyObserver<Element, Error>)
}
extension Signal {
  public init(just element: Element)
  public init(just element: Element, after interval: Swift.Double, queue: Dispatch.DispatchQueue = DispatchQueue(label: "com.mbark.signal.just_after"))
  public init(performing body: @escaping () -> Element)
  public init(result: Swift.Result<Element, Error>)
  public init<Other>(deferring makeSignal: @escaping () -> Other) where Element == Other.Element, Error == Other.Error, Other : SignalProtocol
  public init(evaluating body: @escaping () -> Swift.Result<Element, Error>)
  public init<S>(sequence: S) where Element == S.Element, S : Swift.Sequence
  public init<S>(sequence: S, interval: Swift.Double, queue: Dispatch.DispatchQueue = DispatchQueue(label: "com.mbark.signal.sequence")) where Element == S.Element, S : Swift.Sequence
  public init<S>(flattening signals: S, strategy: FlattenStrategy) where Element == S.Element.Element, Error == S.Element.Error, S : Swift.Sequence, S.Element : SignalProtocol
  public init<S>(combiningLatest signals: S, combine: @escaping ([S.Element.Element]) -> Element) where Error == S.Element.Error, S : Swift.Collection, S.Element : SignalProtocol
}
extension Signal where Error == Swift.Error {
  public init(catching body: @escaping () throws -> Element)
}
public protocol Subscription : Cancellable {
  func request(_ demand: Subscribers.Demand)
}
public struct ExecutionContext {
  public init(_ context: @escaping (@escaping () -> Swift.Void) -> Swift.Void)
  public static var immediate: ExecutionContext {
    get
  }
  public static var immediateOnMain: ExecutionContext {
    get
  }
  public static var main: ExecutionContext {
    get
  }
  public let context: (@escaping () -> Swift.Void) -> Swift.Void
  @available(OSX 10.10, *)
  public static func global(qos: Dispatch.DispatchQoS.QoSClass = .default) -> ExecutionContext
  public static func nonRecursive() -> ExecutionContext
  public func execute(_ block: @escaping () -> Swift.Void)
}
extension DispatchQueue {
  public var context: ExecutionContext {
    get
  }
  @available(*, deprecated, message: "Please use asyncAfter(deadline:execute:)")
  public func after(when interval: Swift.Double, block: @escaping () -> Swift.Void)
  public func disposableAfter(when interval: Swift.Double, block: @escaping () -> Swift.Void) -> Disposable
}
@_hasMissingDesignatedInitializers public class MbarkInstance : Swift.CustomDebugStringConvertible {
  @objc deinit
  public var debugDescription: Swift.String {
    get
  }
  public func track(eventType: MbarkEventType, step: Swift.String? = nil, component: Swift.String? = nil, data: MbarkEventData? = nil)
}
public enum Subscribers {
  public enum Completion<Failure> where Failure : Swift.Error {
    case finished
    case failure(Failure)
  }
}
extension SignalProtocol {
  public func map<U>(_ transform: @escaping (Self.Element) -> U) -> Signal<U, Self.Error>
  public func flatMap<O>(_ strategy: FlattenStrategy, _ transform: @escaping (Self.Element) -> O) -> Signal<O.Element, Self.Error> where O : SignalProtocol, Self.Error == O.Error
  public func flatMapConcat<O>(_ transform: @escaping (Self.Element) -> O) -> Signal<O.Element, Self.Error> where O : SignalProtocol, Self.Error == O.Error
  public func flatMapLatest<O>(_ transform: @escaping (Self.Element) -> O) -> Signal<O.Element, Self.Error> where O : SignalProtocol, Self.Error == O.Error
  public func flatMapMerge<O>(_ transform: @escaping (Self.Element) -> O) -> Signal<O.Element, Self.Error> where O : SignalProtocol, Self.Error == O.Error
  public func flatMapError<S>(_ recover: @escaping (Self.Error) -> S) -> Signal<Self.Element, S.Error> where S : SignalProtocol, Self.Element == S.Element
}
extension SignalProtocol where Self.Error == Swift.Error {
  public func map<U>(_ transform: @escaping (Self.Element) throws -> U) -> Signal<U, Self.Error>
}
public enum FlattenStrategy {
  case concat
  case latest
  case merge
  public static func == (a: FlattenStrategy, b: FlattenStrategy) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
extension SignalProtocol where Self.Element : SignalProtocol, Self.Error == Self.Element.Error {
  public typealias InnerElement = Self.Element.Element
  public func flatten(_ strategy: FlattenStrategy) -> Signal<Self.InnerElement, Self.Error>
  public func merge() -> Signal<Self.InnerElement, Self.Error>
  public func switchToLatest() -> Signal<Self.InnerElement, Self.Error>
  public func concat() -> Signal<Self.InnerElement, Self.Error>
}
extension SignalProtocol where Self.Error == Swift.Never {
  public func flatMap<O>(_ strategy: FlattenStrategy, _ transform: @escaping (Self.Element) -> O) -> Signal<O.Element, O.Error> where O : SignalProtocol
  public func flatMapConcat<O>(_ transform: @escaping (Self.Element) -> O) -> Signal<O.Element, O.Error> where O : SignalProtocol
  public func flatMapLatest<O>(_ transform: @escaping (Self.Element) -> O) -> Signal<O.Element, O.Error> where O : SignalProtocol
  public func flatMapMerge<O>(_ transform: @escaping (Self.Element) -> O) -> Signal<O.Element, O.Error> where O : SignalProtocol
}
extension SignalProtocol where Self.Element : SignalProtocol, Self.Error == Swift.Never {
  public func flatten(_ strategy: FlattenStrategy) -> Signal<Self.Element.Element, Self.Element.Error>
}
extension Subscribers {
  public struct Demand : Swift.Equatable, Swift.Hashable {
    public let value: Swift.Int
    public static let unlimited: Subscribers.Demand
    @available(*, unavailable, message: "Not supported yet.")
    public static func max(_ value: Swift.Int) -> Subscribers.Demand
    public static func == (a: Subscribers.Demand, b: Subscribers.Demand) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
}
public typealias CGPoint = CoreGraphics.CGPoint
public typealias Observer<Element, Error> = (Signal<Element, Error>.Event) -> Swift.Void where Error : Swift.Error
public typealias SafeObserver<Element> = (Signal<Element, Swift.Never>.Event) -> Swift.Void
public protocol ObserverProtocol {
  associatedtype Element
  associatedtype Error : Swift.Error
  func on(_ event: Signal<Self.Element, Self.Error>.Event)
}
public struct AnyObserver<Element, Error> : ObserverProtocol where Error : Swift.Error {
  public let observer: Observer<Element, Error>
  public init(observer: @escaping Observer<Element, Error>)
  public func on(_ event: Signal<Element, Error>.Event)
}
final public class AtomicObserver<Element, Error> : ObserverProtocol, Disposable where Error : Swift.Error {
  public init(_ observer: @escaping Observer<Element, Error>)
  @available(*, deprecated, message: "Will be remove in favour of `init(_:)`. AtomicObserver is a Disposable itself now.")
  convenience public init(disposable: Disposable, observer: @escaping Observer<Element, Error>)
  final public var isDisposed: Swift.Bool {
    get
  }
  final public func on(_ event: Signal<Element, Error>.Event)
  final public func attach(_ producer: (AtomicObserver<Element, Error>) -> Disposable)
  final public func dispose()
  @objc deinit
}
extension ObserverProtocol {
  public func receive(_ element: Self.Element)
  public func receive(completion: Subscribers.Completion<Self.Error>)
  public func receive(lastElement element: Self.Element)
  public func toObserver() -> Observer<Self.Element, Self.Error>
}
extension ObserverProtocol where Self.Element == Swift.Void {
  public func receive()
}
public class LoadingProperty<LoadingValue, LoadingError> : PropertyProtocol, SignalProtocol, DisposeBagProvider where LoadingError : Swift.Error {
  public init(_ signalProducer: @escaping () -> LoadingSignal<LoadingValue, LoadingError>)
  public var bag: DisposeBag {
    get
  }
  public var loadingState: LoadingState<LoadingValue, LoadingError> {
    get
  }
  public var value: LoadingValue? {
    get
    set
  }
  public func reload(silently: Swift.Bool = true) -> LoadingSignal<LoadingValue, LoadingError>
  public func observe(with observer: @escaping (Signal<LoadingState<LoadingValue, LoadingError>, Swift.Never>.Event) -> Swift.Void) -> Disposable
  @objc deinit
  public typealias Element = LoadingState<LoadingValue, LoadingError>
  public typealias Error = Swift.Never
  public typealias ProperyElement = LoadingValue?
}
extension SignalProtocol {
  public func reloading<LoadingValue>(_ property: LoadingProperty<LoadingValue, Self.Error>) -> Signal<Self.Element, Self.Error>
}
extension SignalProtocol where Self.Element : LoadingStateProtocol, Self.Error == Swift.Never {
  public func reloading<V>(_ property: LoadingProperty<V, Self.LoadingError>, strategy: FlattenStrategy = .latest) -> LoadingSignal<Self.LoadingValue, Self.LoadingError>
}
extension CGPoint : Swift.AdditiveArithmetic {
  public static func + (lhs: CGPoint, rhs: CGPoint) -> CGPoint
  public static func - (lhs: CGPoint, rhs: CGPoint) -> CGPoint
  public static func += (lhs: inout CGPoint, rhs: CGPoint)
  public static func -= (lhs: inout CGPoint, rhs: CGPoint)
}
extension SignalProtocol {
  public func buffer(size: Swift.Int) -> Signal<[Self.Element], Self.Error>
  public func collect() -> Signal<[Self.Element], Self.Error>
  public func replaceEmpty(with element: Self.Element) -> Signal<Self.Element, Self.Error>
  public func eraseType() -> Signal<Swift.Void, Self.Error>
  public func pairwise() -> Signal<(Self.Element, Self.Element), Self.Error>
  public func replaceElements<ReplacementElement>(with element: ReplacementElement) -> Signal<ReplacementElement, Self.Error>
  public func reduce<U>(_ initial: U, _ combine: @escaping (U, Self.Element) -> U) -> Signal<U, Self.Error>
  public func scan<U>(_ initial: U, _ combine: @escaping (U, Self.Element) -> U) -> Signal<U, Self.Error>
  public func prepend(_ element: Self.Element) -> Signal<Self.Element, Self.Error>
  public func append(_ element: Self.Element) -> Signal<Self.Element, Self.Error>
  public func window(ofSize size: Swift.Int) -> Signal<Signal<Self.Element, Self.Error>, Self.Error>
  public func zipPrevious() -> Signal<(Self.Element?, Self.Element), Self.Error>
}
extension Subscribers {
  final public class Sink<Input, Failure> : Subscriber, Cancellable where Failure : Swift.Error {
    public init(receiveCompletion: @escaping ((Subscribers.Completion<Failure>) -> Swift.Void), receiveValue: @escaping ((Input) -> Swift.Void))
    final public let receiveValue: (Input) -> Swift.Void
    final public let receiveCompletion: (Subscribers.Completion<Failure>) -> Swift.Void
    final public func receive(subscription: Subscription)
    final public func receive(_ value: Input) -> Subscribers.Demand
    final public func receive(completion: Subscribers.Completion<Failure>)
    final public func cancel()
    @objc deinit
  }
}
extension SignalProtocol {
  public func materialize() -> Signal<Signal<Self.Element, Self.Error>.Event, Swift.Never>
  public func dematerialize<U, E>() -> Signal<U, E> where E == Self.Error, Self.Element == Signal<U, E>.Event
}
extension SignalProtocol where Self.Error == Swift.Never {
  public func dematerialize<U, E>() -> Signal<U, E> where E : Swift.Error, Self.Element == Signal<U, E>.Event
}
public protocol SubjectProtocol : ObserverProtocol, SignalProtocol {
}
extension SubjectProtocol {
  public func send(_ element: Self.Element)
  public func send(completion: Subscribers.Completion<Self.Error>)
  public func send(lastElement element: Self.Element)
}
extension SubjectProtocol where Self.Element == Swift.Void {
  public func send()
}
open class Subject<Element, Error> : SubjectProtocol where Error : Swift.Error {
  public init()
  open func on(_ event: Signal<Element, Error>.Event)
  open func observe(with observer: @escaping Observer<Element, Error>) -> Disposable
  public var isTerminated: Swift.Bool {
    get
  }
  final public let disposeBag: DisposeBag
  @objc deinit
}
extension Subject : BindableProtocol {
  public func bind(signal: Signal<Element, Swift.Never>) -> Disposable
}
@_inheritsConvenienceInitializers final public class PassthroughSubject<Element, Error> : Subject<Element, Error> where Error : Swift.Error {
  override public init()
  override final public func on(_ event: Signal<Element, Error>.Event)
  override final public func observe(with observer: @escaping (Signal<Element, Error>.Event) -> Swift.Void) -> Disposable
  @objc deinit
}
final public class ReplaySubject<Element, Error> : Subject<Element, Error> where Error : Swift.Error {
  public init(bufferSize: Swift.Int = Int.max)
  final public let bufferSize: Swift.Int
  override final public func on(_ event: Signal<Element, Error>.Event)
  override final public func observe(with observer: @escaping (Signal<Element, Error>.Event) -> Swift.Void) -> Disposable
  override public init()
  @objc deinit
}
public typealias SafeReplaySubject<Element> = ReplaySubject<Element, Swift.Never>
@_inheritsConvenienceInitializers final public class ReplayOneSubject<Element, Error> : Subject<Element, Error> where Error : Swift.Error {
  override public init()
  override final public func on(_ event: Signal<Element, Error>.Event)
  override final public func observe(with observer: @escaping (Signal<Element, Error>.Event) -> Swift.Void) -> Disposable
  @objc deinit
}
public typealias SafeReplayOneSubject<Element> = ReplayOneSubject<Element, Swift.Never>
final public class ReplayLoadingValueSubject<Val, LoadingError, Error> : Subject<LoadingState<Val, LoadingError>, Error> where LoadingError : Swift.Error, Error : Swift.Error {
  public init(bufferSize: Swift.Int = Int.max)
  final public let bufferSize: Swift.Int
  override final public func on(_ event: Signal<LoadingState<Val, LoadingError>, Error>.Event)
  override final public func observe(with observer: @escaping (Signal<LoadingState<Val, LoadingError>, Error>.Event) -> Swift.Void) -> Disposable
  override public init()
  @objc deinit
}
extension SignalProtocol {
  public func mapError<F>(_ transform: @escaping (Self.Error) -> F) -> Signal<Self.Element, F> where F : Swift.Error
  public func branchOutError() -> (Signal<Self.Element, Swift.Never>, Signal<Self.Error, Swift.Never>)
  public func branchOutError<F>(_ mapError: @escaping (Self.Error) -> F) -> (Signal<Self.Element, Swift.Never>, Signal<F, Swift.Never>)
  public func suppressError(logging: Swift.Bool, file: Swift.String = #file, line: Swift.Int = #line) -> Signal<Self.Element, Swift.Never>
  public func suppressAndFeedError<S>(into listener: S, logging: Swift.Bool = true, file: Swift.String = #file, line: Swift.Int = #line) -> Signal<Self.Element, Swift.Never> where S : SubjectProtocol, Self.Error == S.Element
  public func replaceError(with element: Self.Element) -> Signal<Self.Element, Swift.Never>
  public func retry(_ times: Swift.Int, if shouldRetry: @escaping (Self.Error) -> Swift.Bool = { _ in true }) -> Signal<Self.Element, Self.Error>
  public func retry<S>(when other: S, if shouldRetry: @escaping (Self.Error) -> Swift.Bool = { _ in true }) -> Signal<Self.Element, Self.Error> where S : SignalProtocol, S.Error == Swift.Never
  public func timeout(after interval: Swift.Double, with error: Self.Error, on queue: Dispatch.DispatchQueue = DispatchQueue(label: "com.mbark.signal.timeout")) -> Signal<Self.Element, Self.Error>
  public func toErrorSignal() -> Signal<Self.Error, Swift.Never>
}
extension SignalProtocol where Self.Error == Swift.Never {
  public func castError<E>() -> Signal<Self.Element, E> where E : Swift.Error
}
@_hasMissingDesignatedInitializers public class Mbark {
  @discardableResult
  public static func initialize(instanceName: Swift.String = UUID().uuidString, selectedLanguage: Swift.String? = nil) -> MbarkInstance?
  @discardableResult
  public static func initialize(token apiToken: Swift.String, instanceName: Swift.String = UUID().uuidString, mbarkUID: Swift.String, flow: Swift.String, flowRevision: Swift.Int, selectedLanguage: Swift.String? = nil) -> MbarkInstance
  public static func getInstance(name: Swift.String) -> MbarkInstance?
  public static func mainInstance() -> MbarkInstance
  public static func setMainInstance(name: Swift.String)
  public static func removeInstance(name: Swift.String)
  public static func track(eventType: MbarkEventType, step: Swift.String? = nil, component: Swift.String? = nil, data: MbarkEventData? = nil)
  @objc deinit
}
public enum MbarkConstants {
  public static let flushInterval: Swift.Double
  public static let baseURL: Foundation.URL
}
extension SignalProtocol {
  public func flatMap<NewElement>(_ transform: @escaping (Self.Element) -> [NewElement]) -> Signal<NewElement, Self.Error>
}
extension SignalProtocol where Self.Element : Swift.Sequence {
  public func mapElement<NewElement>(_ transform: @escaping (Self.Element.Iterator.Element) -> NewElement) -> Signal<[NewElement], Self.Error>
  public func flattenElements() -> Signal<Self.Element.Iterator.Element, Self.Error>
}
extension TimelaneLaneType : Swift.Equatable {}
extension TimelaneLaneType : Swift.Hashable {}
extension TimelaneLaneType : Swift.RawRepresentable {}
extension MbarkEventType : Swift.Equatable {}
extension MbarkEventType : Swift.Hashable {}
extension MbarkEventType : Swift.RawRepresentable {}
extension FlattenStrategy : Swift.Equatable {}
extension FlattenStrategy : Swift.Hashable {}
