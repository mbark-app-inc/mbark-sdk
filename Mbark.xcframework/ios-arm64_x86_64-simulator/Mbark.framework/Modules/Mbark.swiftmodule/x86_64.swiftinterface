// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.4.2 (swiftlang-1205.0.28.2 clang-1205.0.19.57)
// swift-module-flags: -target x86_64-apple-ios12.0-simulator -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -module-name Mbark
import AVFoundation
import Combine
import CommonCrypto
import CoreGraphics
import CoreImage
import CoreTelephony
import Dispatch
import Foundation
import ImageIO
import MachO
@_exported import Mbark
import Metal
import MetalKit
import Network
import ObjectiveC
import Security
import StoreKit
import Swift
import SystemConfiguration
import UIKit.UIColor
import UIKit.UIFont
import UIKit.UIImage
import UIKit
import UserNotifications
import VideoToolbox
import MachO.dyld
import os
import ObjectiveC.runtime
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Publisher {
  public func toSignal() -> Signal<Self.Output, Self.Failure>
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Signal {
  public struct CombinePublisher : Combine.Publisher {
    public typealias Output = Element
    public typealias Failure = Error
    public func receive<S>(subscriber: S) where Element == S.Input, Error == S.Failure, S : Combine.Subscriber
  }
  public func toPublisher() -> Signal<Element, Error>.CombinePublisher
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension SignalProtocol {
  public func toPublisher() -> Signal<Self.Element, Self.Error>.CombinePublisher
}
extension MTLPixelFormat {
  public static let unspecified: Metal.MTLPixelFormat
  public static let yCbCr8_420_2p: Metal.MTLPixelFormat
  public static let yCbCr8_420_2p_srgb: Metal.MTLPixelFormat
  public static let yCbCr10_420_2p: Metal.MTLPixelFormat
  public static let yCbCr10_420_2p_srgb: Metal.MTLPixelFormat
}
public struct Deferred<DeferredSignal> : SignalProtocol where DeferredSignal : SignalProtocol {
  public init(signalFactory: @escaping () -> DeferredSignal)
  public typealias Element = DeferredSignal.Element
  public typealias Error = DeferredSignal.Error
  public let signalFactory: () -> DeferredSignal
  public func observe(with observer: @escaping (Signal<DeferredSignal.Element, DeferredSignal.Error>.Event) -> Swift.Void) -> Disposable
}
extension Subscribers {
  final public class Accumulator<Input, Failure> : Subscriber, Cancellable where Failure : Swift.Error {
    public init()
    final public var values: [Input] {
      get
    }
    final public var isFinished: Swift.Bool {
      get
    }
    final public var isFailure: Swift.Bool {
      get
    }
    final public var error: Failure? {
      get
    }
    final public func receive(subscription: Subscription)
    final public func receive(_ value: Input) -> Subscribers.Demand
    final public func receive(completion: Subscribers.Completion<Failure>)
    final public func cancel()
    @objc deinit
  }
}
public protocol ReactiveExtensions {
  associatedtype Base
  var base: Self.Base { get }
}
public struct Reactive<Base> : ReactiveExtensions {
  public let base: Base
  public init(_ base: Base)
}
public protocol ReactiveExtensionsProvider : AnyObject {
}
extension ReactiveExtensionsProvider {
  public static var reactive: Reactive<Self>.Type {
    get
  }
  public var reactive: Reactive<Self> {
    get
  }
}
extension NSObject : ReactiveExtensionsProvider {
}
extension ReactiveExtensions where Self.Base : ObjectiveC.NSObject {
  public var deallocated: SafeSignal<Swift.Void> {
    get
  }
  public var bag: DisposeBag {
    get
  }
  public func publisher<Value>(for keyPath: Swift.KeyPath<Self.Base, Value>, options: Foundation.NSKeyValueObservingOptions = [.initial, .new]) -> Signal<Value, Swift.Never>
}
extension UIResponder {
  public var mbarkId: Swift.String? {
    get
  }
}
extension EffectsImage {
  public func applyingAssetTrackTransform(_ transform: CoreGraphics.CGAffineTransform) -> EffectsImage
}
public protocol EffectsVideoCompositionRequest {
  func sourceFrame(byTrackID trackID: CoreMedia.CMPersistentTrackID) -> CoreVideo.CVPixelBuffer?
  var renderContext: AVFoundation.AVVideoCompositionRenderContext { get }
  var compositionTime: CoreMedia.CMTime { get }
  var isTrackTransformApplied: Swift.Bool { get }
}
public protocol EffectsMutableVideoCompositionRequest : EffectsVideoCompositionRequest {
  func finish(_ result: Swift.Result<CoreVideo.CVPixelBuffer, Swift.Error>)
}
public protocol EffectsTrackedVideoCompositionRequest : EffectsVideoCompositionRequest {
  var isCancelled: Swift.Bool { get }
}
extension AVAsynchronousVideoCompositionRequest : EffectsMutableVideoCompositionRequest {
  public var isTrackTransformApplied: Swift.Bool {
    get
  }
  public func finish(_ result: Swift.Result<CoreVideo.CVPixelBuffer, Swift.Error>)
}
public class EffectsVideoCompositionRequestHandler {
  public init(context: EffectsContext, tracks: [AVFoundation.AVAssetTrack], on queue: Dispatch.DispatchQueue?, filter: @escaping (EffectsVideoCompositionRequestHandler.Request) throws -> EffectsImage)
  public enum Error : Swift.Error {
    case cannotGenerateOutputPixelBuffer
    public static func == (a: EffectsVideoCompositionRequestHandler.Error, b: EffectsVideoCompositionRequestHandler.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public struct Request {
    public let sourceImages: [CoreMedia.CMPersistentTrackID : EffectsImage]
    public let compositionTime: CoreMedia.CMTime
    public let renderSize: CoreGraphics.CGSize
    public var anySourceImage: EffectsImage {
      get
    }
  }
  public func handle(request: EffectsMutableVideoCompositionRequest)
  @objc deinit
}
public class EffectsVideoComposition {
  public init(asset inputAsset: AVFoundation.AVAsset, context: EffectsContext, queue: Dispatch.DispatchQueue?, filter: @escaping (EffectsVideoCompositionRequestHandler.Request) throws -> EffectsImage)
  public enum Error : Swift.Error {
    case unsupportedInstruction
    public static func == (a: EffectsVideoComposition.Error, b: EffectsVideoComposition.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  final public let asset: AVFoundation.AVAsset
  @available(iOS 11.0, macOS 10.13, *)
  public var sourceTrackIDForFrameTiming: CoreMedia.CMPersistentTrackID {
    get
    set
  }
  public var frameDuration: CoreMedia.CMTime {
    get
    set
  }
  public var renderSize: CoreGraphics.CGSize {
    get
    set
  }
  @available(iOS 11, macOS 10.14, *)
  public var renderScale: Swift.Float {
    get
    set
  }
  public func makeAVVideoComposition() -> AVFoundation.AVVideoComposition
  @objc deinit
}
extension SignalProtocol {
  public func subscribe<S>(on scheduler: S) -> Signal<Self.Element, Self.Error> where S : Scheduler
  public func receive<S>(on scheduler: S) -> Signal<Self.Element, Self.Error> where S : Scheduler
}
public protocol EffectsImageViewProtocol : AnyObject {
  var automaticallyCreatesContext: Swift.Bool { get set }
  var colorPixelFormat: Metal.MTLPixelFormat { get set }
  var clearColor: Metal.MTLClearColor { get set }
  var resizingMode: EffectsDrawableRenderingResizingMode { get set }
  var context: EffectsContext? { get set }
  var image: EffectsImage? { get set }
}
extension EffectsImageViewProtocol {
  public var inputPort: Port<Self, EffectsImage?, Swift.ReferenceWritableKeyPath<Self, EffectsImage?>> {
    get
  }
}
extension EffectsImageView : EffectsImageViewProtocol {
}
extension EffectsThreadSafeImageView : EffectsImageViewProtocol {
}
extension EffectsImageView : InputPortProvider {
  public typealias Port = Port<EffectsImageView, EffectsImage?, Swift.ReferenceWritableKeyPath<EffectsImageView, EffectsImage?>>
}
extension EffectsThreadSafeImageView : InputPortProvider {
  public typealias Port = Port<EffectsThreadSafeImageView, EffectsImage?, Swift.ReferenceWritableKeyPath<EffectsThreadSafeImageView, EffectsImage?>>
}
extension Mustache {
  public static func isFoundationBaseType(value vv: Any) -> Swift.Bool
  public static func isMustacheTrue(value v: Any?) -> Swift.Bool
}
extension EffectsColor : Swift.Hashable {
  public static func == (lhs: EffectsColor, rhs: EffectsColor) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension UITextField {
  public func setMbarkId(_ id: Swift.String?, trackEvents: Swift.Bool = true)
}
public class MbarkActionHandler : MbarkHandler {
  public typealias Handler = () -> Swift.Void
  public var finish: ((Swift.Bool) -> Swift.Void)?
  public init(id: Swift.String, handler: @escaping MbarkActionHandler.Handler)
  final public let id: Swift.String
  final public let handle: MbarkActionHandler.Handler
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
extension MbarkActionHandler : Swift.Equatable {
  public static func == (lhs: MbarkActionHandler, rhs: MbarkActionHandler) -> Swift.Bool
}
extension UITextView {
  public func setMbarkId(_ id: Swift.String?, trackEvents: Swift.Bool = true)
}
extension EffectsComputeFunctionDispatchOptions {
  convenience public init(_ generator: @escaping (Metal.MTLComputePipelineState) -> (threads: Metal.MTLSize, threadgroups: Metal.MTLSize, threadsPerThreadgroup: Metal.MTLSize))
}
extension SignalProtocol {
  public func amb<O>(with other: O) -> Signal<Self.Element, Self.Error> where O : SignalProtocol, Self.Element == O.Element, Self.Error == O.Error
  public func amb<O>(with other: O) -> Signal<Self.Element, Self.Error> where O : SignalProtocol, Self.Element == O.Element, O.Error == Swift.Never
  public func combineLatest<O, U>(with other: O, combine: @escaping (Self.Element, O.Element) -> U) -> Signal<U, Self.Error> where O : SignalProtocol, Self.Error == O.Error
  public func combineLatest<O>(with other: O) -> Signal<(Self.Element, O.Element), Self.Error> where O : SignalProtocol, Self.Error == O.Error
  public func combineLatest<O, U>(with other: O, combine: @escaping (Self.Element, O.Element) -> U) -> Signal<U, Self.Error> where O : SignalProtocol, O.Error == Swift.Never
  public func combineLatest<O>(with other: O) -> Signal<(Self.Element, O.Element), Self.Error> where O : SignalProtocol, O.Error == Swift.Never
  public func append<O>(_ other: O) -> Signal<Self.Element, Self.Error> where O : SignalProtocol, Self.Element == O.Element, Self.Error == O.Error
  public func append<O>(_ other: O) -> Signal<Self.Element, Self.Error> where O : SignalProtocol, Self.Element == O.Element, O.Error == Swift.Never
  public func prepend<O>(_ other: O) -> Signal<Self.Element, Self.Error> where O : SignalProtocol, Self.Element == O.Element, Self.Error == O.Error
  public func prepend<O>(_ other: O) -> Signal<Self.Element, Self.Error> where O : SignalProtocol, Self.Element == O.Element, O.Error == Swift.Never
  public func merge<O>(with other: O) -> Signal<Self.Element, Self.Error> where O : SignalProtocol, Self.Element == O.Element, Self.Error == O.Error
  public func merge<O>(with other: O) -> Signal<Self.Element, Self.Error> where O : SignalProtocol, Self.Element == O.Element, O.Error == Swift.Never
  public func replayLatest<S>(when other: S) -> Signal<Self.Element, Self.Error> where S : SignalProtocol, S.Error == Swift.Never
  public func with<O, U>(latestFrom other: O, combine: @escaping (Self.Element, O.Element) -> U) -> Signal<U, Self.Error> where O : SignalProtocol, Self.Error == O.Error
  public func with<O>(latestFrom other: O) -> Signal<(Self.Element, O.Element), Self.Error> where O : SignalProtocol, Self.Error == O.Error
  public func with<O, U>(latestFrom other: O, combine: @escaping (Self.Element, O.Element) -> U) -> Signal<U, Self.Error> where O : SignalProtocol, O.Error == Swift.Never
  public func with<O>(latestFrom other: O) -> Signal<(Self.Element, O.Element), Self.Error> where O : SignalProtocol, O.Error == Swift.Never
  public func zip<O, U>(with other: O, combine: @escaping (Self.Element, O.Element) -> U) -> Signal<U, Self.Error> where O : SignalProtocol, Self.Error == O.Error
  public func zip<O>(with other: O) -> Signal<(Self.Element, O.Element), Self.Error> where O : SignalProtocol, Self.Error == O.Error
  public func zip<O, U>(with other: O, combine: @escaping (Self.Element, O.Element) -> U) -> Signal<U, Self.Error> where O : SignalProtocol, O.Error == Swift.Never
  public func zip<O>(with other: O) -> Signal<(Self.Element, O.Element), Self.Error> where O : SignalProtocol, O.Error == Swift.Never
}
extension SignalProtocol where Self.Error == Swift.Never {
  public func amb<O>(with other: O) -> Signal<Self.Element, O.Error> where O : SignalProtocol, Self.Element == O.Element
  public func combineLatest<O, U>(with other: O, combine: @escaping (Self.Element, O.Element) -> U) -> Signal<U, O.Error> where O : SignalProtocol
  public func combineLatest<O>(with other: O) -> Signal<(Self.Element, O.Element), O.Error> where O : SignalProtocol
  public func append<O>(_ other: O) -> Signal<Self.Element, O.Error> where O : SignalProtocol, Self.Element == O.Element
  public func prepend<O>(_ other: O) -> Signal<Self.Element, O.Error> where O : SignalProtocol, Self.Element == O.Element
  public func merge<O>(with other: O) -> Signal<Self.Element, O.Error> where O : SignalProtocol, Self.Element == O.Element
  public func with<O, U>(latestFrom other: O, combine: @escaping (Self.Element, O.Element) -> U) -> Signal<U, O.Error> where O : SignalProtocol
  public func with<O>(latestFrom other: O) -> Signal<(Self.Element, O.Element), O.Error> where O : SignalProtocol
  public func zip<O, U>(with other: O, combine: @escaping (Self.Element, O.Element) -> U) -> Signal<U, O.Error> where O : SignalProtocol
  public func zip<O>(with other: O) -> Signal<(Self.Element, O.Element), O.Error> where O : SignalProtocol
}
public struct MustacheParser {
  public init()
  public var openCharacter: Swift.Character {
    get
    set
  }
  public var closeCharacter: Swift.Character {
    get
    set
  }
  public mutating func parse(string s: Swift.String) -> MustacheNode
  public mutating func parse(cstr cs: Swift.UnsafePointer<Swift.CChar>) -> MustacheNode
}
public protocol PropertyProtocol {
  associatedtype ProperyElement
  var value: Self.ProperyElement { get }
}
final public class Property<Value> : PropertyProtocol, SubjectProtocol, BindableProtocol, DisposeBagProvider {
  public init(_ value: Value, subject: Subject<Value, Swift.Never> = PassthroughSubject())
  @objc deinit
  final public var bag: DisposeBag {
    get
  }
  final public var value: Value {
    get
    set
  }
  final public var readOnlyView: AnyProperty<Value> {
    get
  }
  final public func on(_ event: Signal<Value, Swift.Never>.Event)
  final public func observe(with observer: @escaping (Signal<Value, Swift.Never>.Event) -> Swift.Void) -> Disposable
  final public func silentUpdate(value: Value)
  final public func bind(signal: Signal<Value, Swift.Never>) -> Disposable
  public typealias Element = Value
  public typealias Error = Swift.Never
  public typealias ProperyElement = Value
}
final public class AnyProperty<Value> : PropertyProtocol, SignalProtocol {
  public init(property: Property<Value>)
  final public var value: Value {
    get
  }
  final public func observe(with observer: @escaping (Signal<Value, Swift.Never>.Event) -> Swift.Void) -> Disposable
  public typealias Element = Value
  public typealias Error = Swift.Never
  public typealias ProperyElement = Value
  @objc deinit
}
@dynamicCallable public struct Mustache {
  public let template: MustacheNode
  public init(_ template: Swift.String)
  public static func parse(_ template: Swift.String) -> MustacheNode
  public func render(object: Any?) -> Swift.String
  public func dynamicallyCall(withKeywordArguments args: Swift.KeyValuePairs<Swift.String, Any>) -> Swift.String
}
public struct MbarkEventData : Swift.Codable {
  public init(name: Swift.String, value: Swift.String)
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
public protocol ObservableObject : AnyObject {
  associatedtype ObjectWillChangeSignal : SignalProtocol = Signal<Swift.Void, Swift.Never> where Self.ObjectWillChangeSignal.Error == Swift.Never
  var objectWillChange: Self.ObjectWillChangeSignal { get }
}
extension ObservableObject where Self.ObjectWillChangeSignal == Signal<Swift.Void, Swift.Never> {
  public var objectWillChange: Signal<Swift.Void, Swift.Never> {
    get
  }
}
extension NSLock {
  convenience public init(name: Swift.String)
}
extension NSRecursiveLock {
  convenience public init(name: Swift.String)
}
@objc @_hasMissingDesignatedInitializers public class MbarkViewController : UIKit.UIViewController {
  @objc override dynamic public func viewDidLoad()
  @objc override dynamic public func viewDidLayoutSubviews()
  @available(*, deprecated, message: "Please use addActionHandler(_:) directly")
  public func addActionHandler(_ actionHandler: MbarkActionHandler)
  @available(*, deprecated, message: "Please use removeActionHandler(forId:) directly")
  public func removeActionHandler(forId id: Swift.String)
  @objc override dynamic public init(nibName nibNameOrNil: Swift.String?, bundle nibBundleOrNil: Foundation.Bundle?)
  @objc deinit
}
extension MbarkViewController {
  @objc override dynamic public func motionEnded(_ motion: UIKit.UIEvent.EventSubtype, with event: UIKit.UIEvent?)
}
extension EffectsVector {
  convenience public init(values: [Swift.Float])
  convenience public init(values: [Swift.Int32])
  convenience public init(values: [Swift.UInt32])
  convenience public init(values: [Swift.Int16])
  convenience public init(values: [Swift.UInt16])
  convenience public init(values: [Swift.Int8])
  convenience public init(values: [Swift.UInt8])
}
public struct Empty<Element, Error> : SignalProtocol, Swift.Equatable where Error : Swift.Error {
  public init(completeImmediately: Swift.Bool = true)
  public init(completeImmediately: Swift.Bool = true, outputType: Element.Type, failureType: Error.Type)
  public typealias Element = Element
  public typealias Error = Error
  public let completeImmediately: Swift.Bool
  public func observe(with observer: @escaping (Signal<Element, Error>.Event) -> Swift.Void) -> Disposable
  public static func == (a: Empty<Element, Error>, b: Empty<Element, Error>) -> Swift.Bool
}
extension UIImageView {
  public func setMbarkId(_ id: Swift.String?, trackEvents: Swift.Bool = true)
}
extension SignalProtocol {
  public func breakpoint(receiveSubscription: (() -> Swift.Bool)? = nil, receiveOutput: ((Self.Element) -> Swift.Bool)? = nil, receiveCompletion: ((Subscribers.Completion<Self.Error>) -> Swift.Bool)? = nil) -> Signal<Self.Element, Self.Error>
  public func breakpointOnError() -> Signal<Self.Element, Self.Error>
  public func debug(_ title: Swift.String? = nil, file: Swift.String = #file, function: Swift.String = #function, line: Swift.Int = #line) -> Signal<Self.Element, Self.Error>
  public func delay(interval: Swift.Double, on queue: Dispatch.DispatchQueue = DispatchQueue(label: "mbark.delay")) -> Signal<Self.Element, Self.Error>
  public func `repeat`<S>(when other: @escaping (Self.Element) -> S) -> Signal<Self.Element, Self.Error> where S : SignalProtocol, S.Error == Swift.Never
  public func handleEvents(receiveSubscription: (() -> Swift.Void)? = nil, receiveOutput: ((Self.Element) -> Swift.Void)? = nil, receiveCompletion: ((Subscribers.Completion<Self.Error>) -> Swift.Void)? = nil, receiveCancel: (() -> Swift.Void)? = nil) -> Signal<Self.Element, Self.Error>
  public func feedActivity<S>(into listener: S) -> Signal<Self.Element, Self.Error> where S : SubjectProtocol, S.Element == Swift.Bool
  public func feedNext<S>(into listener: S) -> Signal<Self.Element, Self.Error> where S : SubjectProtocol, Self.Element == S.Element
  public func feedNext<S>(into listener: S, when: @escaping (Self.Element) -> Swift.Bool = { _ in true }, map: @escaping (Self.Element) -> S.Element) -> Signal<Self.Element, Self.Error> where S : SubjectProtocol
  public func feedError<S>(into listener: S) -> Signal<Self.Element, Self.Error> where S : SubjectProtocol, Self.Error == S.Element
  public func waitAndCollectEvents() -> [Signal<Self.Element, Self.Error>.Event]
  public func waitAndCollectElements() -> [Self.Element]
}
public struct ComponentValue : Swift.Codable, Swift.Hashable, Swift.Equatable {
  public let apiID: Swift.String?
  public func hash(into hasher: inout Swift.Hasher)
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
  public static func == (a: ComponentValue, b: ComponentValue) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
extension NSAttributedString : KeyValueCodingType {
}
public struct AttributedMustacheParser {
  public init()
  public var openCharacter: Swift.Character {
    get
    set
  }
  public var closeCharacter: Swift.Character {
    get
    set
  }
  public mutating func parse(attributedString s: Foundation.NSAttributedString) -> AttributedMustacheNode
}
@propertyWrapper public struct Published<Value> {
  public init(wrappedValue: Value)
  public struct Publisher : SignalProtocol {
    public typealias Element = Value
    public typealias Error = Swift.Never
    public func observe(with observer: @escaping (Signal<Value, Swift.Never>.Event) -> Swift.Void) -> Disposable
  }
  public var wrappedValue: Value {
    get
    set
  }
  public var projectedValue: Published<Value>.Publisher {
    mutating get
  }
}
extension UILabel {
  public func setMbarkId(_ id: Swift.String?, trackEvents: Swift.Bool = true)
}
extension CGSize : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public protocol SignalProtocol {
  associatedtype Element
  associatedtype Error : Swift.Error
  func observe(with observer: @escaping Observer<Self.Element, Self.Error>) -> Disposable
}
extension SignalProtocol {
  public func observe<O>(with observer: O) -> Disposable where O : ObserverProtocol, Self.Element == O.Element, Self.Error == O.Error
  public func observeNext(with observer: @escaping (Self.Element) -> Swift.Void) -> Disposable
  public func observeFailed(with observer: @escaping (Self.Error) -> Swift.Void) -> Disposable
  public func observeCompleted(with observer: @escaping () -> Swift.Void) -> Disposable
  public func toSignal() -> Signal<Self.Element, Self.Error>
}
extension SignalProtocol {
  public func sink(receiveCompletion: @escaping ((Subscribers.Completion<Self.Error>) -> Swift.Void), receiveValue: @escaping ((Self.Element) -> Swift.Void)) -> AnyCancellable
}
extension SignalProtocol where Self.Error == Swift.Never {
  public func sink(receiveValue: @escaping ((Self.Element) -> Swift.Void)) -> AnyCancellable
}
extension SignalProtocol where Self.Error == Swift.Never {
  public func assign<Root>(to keyPath: Swift.ReferenceWritableKeyPath<Root, Self.Element>, on object: Root) -> AnyCancellable
}
extension SignalProtocol {
  public func subscribe<Downstream>(_ subscriber: Downstream) where Downstream : Subscriber, Self.Element == Downstream.Input, Self.Error == Downstream.Failure
}
public protocol BindableProtocol {
  associatedtype Element
  func bind(signal: Signal<Self.Element, Swift.Never>) -> Disposable
}
extension SignalProtocol where Self.Error == Swift.Never {
  @discardableResult
  public func bind<B>(to bindable: B) -> Disposable where B : BindableProtocol, Self.Element == B.Element
  @discardableResult
  public func bind<B>(to bindable: B) -> Disposable where B : BindableProtocol, Self.Element == B.Element.Wrapped, B.Element : OptionalProtocol
}
extension BindableProtocol where Self : SignalProtocol, Self.Error == Swift.Never {
  @discardableResult
  public func bidirectionalBind<B>(to target: B) -> Disposable where B : BindableProtocol, B : SignalProtocol, Self.Element == B.Element, B.Error == Swift.Never
}
extension SignalProtocol where Self.Error == Swift.Never {
  @discardableResult
  public func bind<Target>(to target: Target, setter: @escaping (Target, Self.Element) -> Swift.Void) -> Disposable where Target : BindingExecutionContextProvider, Target : Deallocatable
  @discardableResult
  public func bind<Target>(to target: Target, context: ExecutionContext, setter: @escaping (Target, Self.Element) -> Swift.Void) -> Disposable where Target : Deallocatable
  @discardableResult
  public func bind<Target>(to target: Target, keyPath: Swift.ReferenceWritableKeyPath<Target, Self.Element>) -> Disposable where Target : BindingExecutionContextProvider, Target : Deallocatable
  @discardableResult
  public func bind<Target>(to target: Target, keyPath: Swift.ReferenceWritableKeyPath<Target, Self.Element>, context: ExecutionContext) -> Disposable where Target : Deallocatable
}
extension SignalProtocol where Self.Element == Swift.Void, Self.Error == Swift.Never {
  @discardableResult
  public func bind<Target>(to target: Target, setter: @escaping (Target) -> Swift.Void) -> Disposable where Target : BindingExecutionContextProvider, Target : Deallocatable
  @discardableResult
  public func bind<Target>(to target: Target, context: ExecutionContext, setter: @escaping (Target) -> Swift.Void) -> Disposable where Target : Deallocatable
}
public protocol BindingExecutionContextProvider {
  var bindingExecutionContext: ExecutionContext { get }
}
extension SignalProtocol {
  public func mapToResult() -> Signal<Swift.Result<Self.Element, Self.Error>, Swift.Never>
  public func tryMap<U>(_ transform: @escaping (Self.Element) -> Swift.Result<U, Self.Error>) -> Signal<U, Self.Error>
}
extension SignalProtocol where Self.Error == Swift.Never {
  public func tryMap<U, E>(_ transform: @escaping (Self.Element) -> Swift.Result<U, E>) -> Signal<U, E> where E : Swift.Error
}
extension SignalProtocol where Self.Element : _ResultProtocol {
  public func mapValue<NewSuccess>(_ transform: @escaping (Self.Element.Value) -> NewSuccess) -> Signal<Swift.Result<NewSuccess, Self.Element.Error>, Self.Error>
}
extension SignalProtocol where Self.Element : _ResultProtocol, Self.Error == Self.Element.Error {
  public func getValues() -> Signal<Self.Element.Value, Self.Error>
}
extension SignalProtocol where Self.Element : _ResultProtocol, Self.Error == Swift.Never {
  public func getValues() -> Signal<Self.Element.Value, Self.Element.Error>
}
public protocol _ResultProtocol {
  associatedtype Value
  associatedtype Error : Swift.Error
  var _unbox: Swift.Result<Self.Value, Self.Error> { get }
}
extension Result : _ResultProtocol {
  public var _unbox: Swift.Result<Success, Failure> {
    get
  }
  public typealias Error = Failure
  public typealias Value = Success
}
extension UIImageView {
  @objc dynamic open func mbark_display(image: UIKit.UIImage?)
}
extension Signal {
  public enum Event {
    case next(Element)
    case failed(Error)
    case completed
  }
}
extension Signal.Event {
  public var isNext: Swift.Bool {
    get
  }
  public var isFailed: Swift.Bool {
    get
  }
  public var isCompleted: Swift.Bool {
    get
  }
  public var isTerminal: Swift.Bool {
    get
  }
  public var element: Element? {
    get
  }
  public var error: Error? {
    get
  }
}
extension Signal.Event : Swift.Equatable where Element : Swift.Equatable, Error : Swift.Equatable {
  public static func == (a: Signal<Element, Error>.Event, b: Signal<Element, Error>.Event) -> Swift.Bool
}
public protocol Deallocatable : AnyObject {
  var deallocated: SafeSignal<Swift.Void> { get }
}
public protocol DisposeBagProvider : Deallocatable {
  var bag: DisposeBag { get }
}
extension DisposeBagProvider {
  public var deallocated: SafeSignal<Swift.Void> {
    get
  }
}
extension NSObject : DisposeBagProvider {
  public var bag: DisposeBag {
    get
  }
}
public protocol LoadingStateProtocol {
  associatedtype LoadingValue
  associatedtype LoadingError : Swift.Error
  var asLoadingState: LoadingState<Self.LoadingValue, Self.LoadingError> { get }
}
extension LoadingStateProtocol {
  public var isLoading: Swift.Bool {
    get
  }
  public var value: Self.LoadingValue? {
    get
  }
  public var error: Self.LoadingError? {
    get
  }
}
public enum LoadingState<LoadingValue, LoadingError> : LoadingStateProtocol where LoadingError : Swift.Error {
  case loading
  case loaded(LoadingValue)
  case failed(LoadingError)
  public var asLoadingState: LoadingState<LoadingValue, LoadingError> {
    get
  }
}
public protocol ObservedLoadingStateProtocol : LoadingStateProtocol {
  var asObservedLoadingState: ObservedLoadingState<Self.LoadingValue, Self.LoadingError> { get }
}
extension ObservedLoadingStateProtocol {
  public var isReloading: Swift.Bool {
    get
  }
}
public enum ObservedLoadingState<LoadingValue, LoadingError> : ObservedLoadingStateProtocol where LoadingError : Swift.Error {
  case loading
  case reloading
  case loaded(LoadingValue)
  case failed(LoadingError)
  public var asLoadingState: LoadingState<LoadingValue, LoadingError> {
    get
  }
  public var asObservedLoadingState: ObservedLoadingState<LoadingValue, LoadingError> {
    get
  }
}
extension LoadingState {
  public func isSameStateAs<V, E>(_ other: LoadingState<V, E>) -> Swift.Bool where E : Swift.Error
}
public typealias LoadingSignal<LoadingValue, LoadingError> = SafeSignal<LoadingState<LoadingValue, LoadingError>> where LoadingError : Swift.Error
extension SignalProtocol where Self.Element : LoadingStateProtocol, Self.Error == Swift.Never {
  public typealias LoadingValue = Self.Element.LoadingValue
  public typealias LoadingError = Self.Element.LoadingError
  public static func loading() -> LoadingSignal<Self.LoadingValue, Self.LoadingError>
  public static func loaded(_ value: Self.LoadingValue) -> LoadingSignal<Self.LoadingValue, Self.LoadingError>
  public static func failed(_ error: Self.LoadingError) -> LoadingSignal<Self.LoadingValue, Self.LoadingError>
  public func value() -> SafeSignal<Self.LoadingValue>
  public func mapValue<NewValue>(_ transform: @escaping (Self.LoadingValue) -> NewValue) -> LoadingSignal<NewValue, Self.LoadingError>
  public func mapLoadingError<NewError>(_ transform: @escaping (Self.LoadingError) -> NewError) -> LoadingSignal<Self.LoadingValue, NewError> where NewError : Swift.Error
  public func dematerializeLoadingState() -> Signal<Self.LoadingValue, Self.LoadingError>
  public func liftValue<T>(_ transfrom: @escaping (Signal<Self.LoadingValue, Self.LoadingError>) -> Signal<T, Self.LoadingError>) -> LoadingSignal<T, Self.LoadingError>
  public func liftValue<T>(_ transfrom: @escaping (Signal<Self.LoadingValue, Self.LoadingError>) -> LoadingSignal<T, Self.LoadingError>) -> LoadingSignal<T, Self.LoadingError>
  public func flatMapValue<NewValue>(_ strategy: FlattenStrategy = .latest, transfrom: @escaping (Self.LoadingValue) -> LoadingSignal<NewValue, Self.LoadingError>) -> LoadingSignal<NewValue, Self.LoadingError>
  public func flatMapValue<NewValue>(_ strategy: FlattenStrategy = .latest, transfrom: @escaping (Self.LoadingValue) -> Signal<NewValue, Self.LoadingError>) -> LoadingSignal<NewValue, Self.LoadingError>
  public func deriveObservedLoadingState(loadsAgainOnFailure: Swift.Bool = true) -> Signal<ObservedLoadingState<Self.LoadingValue, Self.LoadingError>, Swift.Never>
}
extension SignalProtocol {
  public func toLoadingSignal() -> LoadingSignal<Self.Element, Self.Error>
}
public protocol LoadingStateListener : AnyObject {
  func setLoadingState<LoadingValue, LoadingError>(_ state: ObservedLoadingState<LoadingValue, LoadingError>) where LoadingError : Swift.Error
  var loadingStateListenerNeedsWeakReference: Swift.Bool { get }
}
extension LoadingStateListener {
  public var loadingStateListenerNeedsWeakReference: Swift.Bool {
    get
  }
}
extension SignalProtocol where Self.Element : ObservedLoadingStateProtocol, Self.Error == Swift.Never {
  public func updateLoadingState(of listener: BindingExecutionContextProvider & LoadingStateListener) -> Signal<ObservedLoadingState<Self.LoadingValue, Self.LoadingError>, Swift.Never>
  public func updateLoadingState(of listener: LoadingStateListener, context: ExecutionContext) -> Signal<ObservedLoadingState<Self.LoadingValue, Self.LoadingError>, Swift.Never>
  public func consumeLoadingState(by listener: BindingExecutionContextProvider & LoadingStateListener) -> SafeSignal<Self.LoadingValue>
  public func consumeLoadingState(by listener: LoadingStateListener, context: ExecutionContext) -> SafeSignal<Self.LoadingValue>
}
extension SignalProtocol where Self.Element : LoadingStateProtocol, Self.Error == Swift.Never {
  public func updateLoadingState(of listener: BindingExecutionContextProvider & LoadingStateListener) -> LoadingSignal<Self.LoadingValue, Self.LoadingError>
  public func updateLoadingState(of listener: LoadingStateListener, context: ExecutionContext) -> LoadingSignal<Self.LoadingValue, Self.LoadingError>
  public func consumeLoadingState(by listener: BindingExecutionContextProvider & LoadingStateListener) -> SafeSignal<Self.LoadingValue>
  public func consumeLoadingState(by listener: LoadingStateListener, context: ExecutionContext) -> SafeSignal<Self.LoadingValue>
}
public struct Safe<Base> : Swift.Decodable where Base : Swift.Decodable {
  public let value: Base?
  public init(from decoder: Swift.Decoder) throws
}
public class Configurator {
  public init(name: Swift.String = "")
  public var name: Swift.String
  public func configure(_ id: Swift.String? = nil)
  @objc deinit
}
extension UILabel {
  @objc dynamic open func mbark_display(font: UIKit.UIFont?)
}
extension UITextField {
  @objc dynamic open func mbark_display(font: UIKit.UIFont?)
}
public protocol MbarkHandler : AnyObject, Swift.Hashable {
  associatedtype Handler
  var id: Swift.String { get }
  var handle: Self.Handler { get }
  var finish: ((Swift.Bool) -> Swift.Void)? { get set }
  func onFinish(_ callback: @escaping (Swift.Bool) -> Swift.Void) -> Self
  func finish(success: Swift.Bool)
}
extension MbarkHandler {
  public func hash(into hasher: inout Swift.Hasher)
  @discardableResult
  public func onFinish(_ callback: @escaping (Swift.Bool) -> Swift.Void) -> Self
  public func finish(success: Swift.Bool)
}
extension EffectsVertex {
  public init(position: (Swift.Float, Swift.Float, Swift.Float, Swift.Float), textureCoordinate: (Swift.Float, Swift.Float))
}
extension EffectsVertex : Swift.Equatable {
  public static func == (lhs: EffectsVertex, rhs: EffectsVertex) -> Swift.Bool
}
extension EffectsVertex : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension EffectsVertices {
  convenience public init(vertices: [EffectsVertex], primitiveType: Metal.MTLPrimitiveType)
  convenience public init(vertexBuffer: EffectsDataBuffer, vertexCount: Swift.Int, indexBuffer: EffectsDataBuffer?, indexCount: Swift.Int?, primitiveType: Metal.MTLPrimitiveType)
}
extension EffectsDataBuffer {
  convenience public init?(EffectsVertices: [EffectsVertex])
  convenience public init?(uint32Indexes: [Swift.UInt32])
}
public enum TimelaneLaneType : Swift.Int, Swift.CaseIterable {
  case subscription, event
  public init?(rawValue: Swift.Int)
  public typealias AllCases = [TimelaneLaneType]
  public typealias RawValue = Swift.Int
  public static var allCases: [TimelaneLaneType] {
    get
  }
  public var rawValue: Swift.Int {
    get
  }
}
extension SignalProtocol {
  public func laneIfAvailable(_ name: Swift.String, filter: Swift.Set<TimelaneLaneType> = Set(TimelaneLaneType.allCases), file: Swift.StaticString = #file, function: Swift.StaticString = #function, line: Swift.UInt = #line) -> Signal<Self.Element, Self.Error>
  @available(macOS 10.14, iOS 12, tvOS 12, watchOS 5, *)
  public func lane(_ name: Swift.String, filter: Swift.Set<TimelaneLaneType> = Set(TimelaneLaneType.allCases), file: Swift.StaticString = #file, function: Swift.StaticString = #function, line: Swift.UInt = #line) -> Signal<Self.Element, Self.Error>
}
public enum MbarkEventType : Swift.String {
  case accept
  case authenticate
  case background
  case foreground
  case flowStart
  case flowEnd
  case input
  case longPress
  case reject
  case swipeLeft
  case swipeRight
  case tap
  case view
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum MbarkStepNames : Swift.String {
  case loading
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum AuthenticationUserType : Swift.String {
  case new
  case existing
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public protocol Scheduler {
  func schedule(_ action: @escaping () -> Swift.Void)
}
extension ExecutionContext : Scheduler {
  public func schedule(_ action: @escaping () -> Swift.Void)
}
extension DispatchQueue : Scheduler {
  public func schedule(_ action: @escaping () -> Swift.Void)
}
@_inheritsConvenienceInitializers @objc(EffectsSIMDArgumentEncoder) public class EffectsSIMDArgumentEncoder : ObjectiveC.NSObject, EffectsFunctionArgumentEncoding {
  public enum Error : Swift.String, Swift.Error, Foundation.LocalizedError {
    case argumentTypeMismatch
    public var errorDescription: Swift.String? {
      get
    }
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  @objc public static func encodeValue(_ value: Any, argument: Metal.MTLArgument, proxy: EffectsFunctionArgumentEncodingProxy) throws
  @objc override dynamic public init()
  @objc deinit
}
public protocol KeyValueCodingType {
  func value(forKey k: Swift.String) -> Any?
}
extension KeyValueCodingType {
  public func value(forKey k: Swift.String) -> Any?
}
public struct KeyValueCoding {
  public static func value(forKeyPath p: Swift.String, inObject o: Any?) -> Any?
  public static func value(forKey k: Swift.String, inObject o: Any?) -> Any?
  public static func defaultValue(forKey k: Swift.String, inObject o: Any?) -> Any?
}
extension KeyValueCoding {
  public static func defaultValue(forKey k: Swift.String, inDictionary o: Any, mirror: Swift.Mirror) -> Any?
}
@objc @_hasMissingDesignatedInitializers public class GridView : UIKit.UIView {
  public init(frame: CoreGraphics.CGRect, columns: Swift.Int, rows: Swift.Int, padding: CoreGraphics.CGFloat)
  @objc override dynamic public func draw(_ rect: CoreGraphics.CGRect)
  @objc override dynamic public init(frame: CoreGraphics.CGRect)
  @objc deinit
}
public protocol Subscriber {
  associatedtype Input
  associatedtype Failure : Swift.Error
  func receive(subscription: Subscription)
  func receive(_ input: Self.Input) -> Subscribers.Demand
  func receive(completion: Subscribers.Completion<Self.Failure>)
}
extension Subscriber where Self.Input == Swift.Void {
  public func receive() -> Subscribers.Demand
}
public protocol Cancellable {
  func cancel()
}
extension EffectsRGBColorSpaceConversionFilter {
  public static func convert(_ image: EffectsImage, from inputColorSpace: EffectsRGBColorSpace, to outputColorSpace: EffectsRGBColorSpace, alphaType: EffectsAlphaType, pixelFormat: Metal.MTLPixelFormat = .unspecified) -> EffectsImage
}
extension UIViewController {
  public func setMbarkId(_ id: Swift.String?, trackEvents: Swift.Bool = true)
}
public protocol ConnectableSignalProtocol : SignalProtocol {
  func connect() -> Disposable
}
final public class ConnectableSignal<Source> : ConnectableSignalProtocol where Source : SignalProtocol {
  public init(source: Source, subject: Subject<Source.Element, Source.Error>)
  final public func connect() -> Disposable
  final public func observe(with observer: @escaping (Signal<Source.Element, Source.Error>.Event) -> Swift.Void) -> Disposable
  public typealias Element = Source.Element
  public typealias Error = Source.Error
  @objc deinit
}
extension ConnectableSignalProtocol {
  public func refCount(disconnectCount: Swift.Int = 0) -> Signal<Self.Element, Self.Error>
}
extension SignalProtocol {
  public func multicast(_ createSubject: () -> Subject<Self.Element, Self.Error>) -> ConnectableSignal<Self>
  public func multicast(subject: Subject<Self.Element, Self.Error>) -> ConnectableSignal<Self>
  public func replay(limit: Swift.Int = Int.max) -> ConnectableSignal<Self>
  public func publish() -> ConnectableSignal<Self>
  public func share(limit: Swift.Int = Int.max, keepAlive: Swift.Bool = false) -> Signal<Self.Element, Self.Error>
}
extension SignalProtocol where Self.Element : LoadingStateProtocol {
  public func replayValues(limit: Swift.Int = Int.max) -> ConnectableSignal<Signal<LoadingState<Self.Element.LoadingValue, Self.Element.LoadingError>, Self.Error>>
  public func shareReplayValues(limit: Swift.Int = Int.max) -> Signal<LoadingState<Self.Element.LoadingValue, Self.Element.LoadingError>, Self.Error>
}
final public class EffectsDisplacementTransition {
  @discardableResult
  public init(from image: EffectsImage, to targetImage: EffectsImage, displacementMap displacement: EffectsImage, options: EffectsDisplacementTransition.Options, updater: @escaping (EffectsImage) -> Swift.Void, completion: ((Swift.Bool) -> Swift.Void)?)
  @objc @_inheritsConvenienceInitializers final public class Filter : ObjectiveC.NSObject, EffectsFilter {
    @objc final public var outputPixelFormat: Metal.MTLPixelFormat
    final public var inputImage: EffectsImage?
    final public var inputTargetImage: EffectsImage?
    final public var inputDisplacementImage: EffectsImage?
    final public var displacementIntensity: Swift.Float
    final public var angle: Swift.Float
    final public var progress: Swift.Float
    @objc final public var outputImage: EffectsImage? {
      @objc get
    }
    @objc override dynamic public init()
    @objc deinit
  }
  public struct Options {
    public var angle: Swift.Float
    public var displacementIntensity: Swift.Float
    public var duration: Swift.Double
    public var timingFunction: (Swift.Float) -> Swift.Float
    public init()
  }
  final public func cancel()
  @objc deinit
}
final public class CGImageDisplacementTransition {
  @discardableResult
  public init(from image: CoreGraphics.CGImage, to targetImage: CoreGraphics.CGImage, displacementMap displacement: CoreGraphics.CGImage, options: EffectsDisplacementTransition.Options, updater: @escaping (CoreGraphics.CGImage) -> Swift.Void, completion: ((Swift.Bool) -> Swift.Void)?) throws
  public enum Error : Swift.Error {
    case noMetalDeviceFound
    public static func == (a: CGImageDisplacementTransition.Error, b: CGImageDisplacementTransition.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  @discardableResult
  public static func transition(from image: CoreGraphics.CGImage, to targetImage: CoreGraphics.CGImage, displacementMap displacement: CoreGraphics.CGImage, options: EffectsDisplacementTransition.Options, updater: @escaping (CoreGraphics.CGImage) -> Swift.Void, completion: ((Swift.Bool) -> Swift.Void)?) throws -> CGImageDisplacementTransition
  final public func cancel()
  @objc deinit
}
@objc final public class ViewControllerDisplacementTransition : ObjectiveC.NSObject, UIKit.UIViewControllerAnimatedTransitioning {
  public init(displacementMap displacement: CoreGraphics.CGImage, options: EffectsDisplacementTransition.Options)
  @objc final public func transitionDuration(using transitionContext: UIKit.UIViewControllerContextTransitioning?) -> Foundation.TimeInterval
  @objc final public func animateTransition(using transitionContext: UIKit.UIViewControllerContextTransitioning)
  @objc override dynamic public init()
  @objc deinit
}
extension AttributedMustacheNode {
  public func render(object o: Any?, cb: (Foundation.NSAttributedString) -> Swift.Void)
  public func render(object o: Any?) -> Foundation.NSAttributedString
  public func render(nodes nl: [AttributedMustacheNode], inContext ctx: AttributedMustacheRenderingContext)
  public func render(inContext ctx: AttributedMustacheRenderingContext, cb: (Foundation.NSAttributedString) -> Swift.Void)
  public func render(inContext ctx: AttributedMustacheRenderingContext)
  public func render(lambda cb: (Foundation.NSAttributedString, (Foundation.NSAttributedString) -> Foundation.NSAttributedString) -> Foundation.NSAttributedString, nodes nl: [AttributedMustacheNode], inContext ctx: AttributedMustacheRenderingContext)
  public func render(lambda cb: (Swift.String, (Swift.String) -> Swift.String) -> Swift.String, nodes nl: [AttributedMustacheNode], inContext ctx: AttributedMustacheRenderingContext)
}
extension AttributedMustacheNode {
  public func render(section tag: Swift.String, nodes: [AttributedMustacheNode], inContext ctx: AttributedMustacheRenderingContext)
}
extension EffectsTextureDimensions : Swift.Equatable {
  public init(width: Swift.Int, height: Swift.Int, depth: Swift.Int = 1)
  public static func == (lhs: EffectsTextureDimensions, rhs: EffectsTextureDimensions) -> Swift.Bool
}
extension SignalProtocol {
  public func debounce(for seconds: Swift.Double, queue: Dispatch.DispatchQueue = DispatchQueue(label: "com.mbark.signal.debounce")) -> Signal<Self.Element, Self.Error>
  public func removeDuplicates(by areEqual: @escaping (Self.Element, Self.Element) -> Swift.Bool) -> Signal<Self.Element, Self.Error>
  public func output(at index: Swift.Int) -> Signal<Self.Element, Self.Error>
  public func filter(_ isIncluded: @escaping (Self.Element) -> Swift.Bool) -> Signal<Self.Element, Self.Error>
  public func flatMapFilter(_ strategy: FlattenStrategy = .concat, _ isIncluded: @escaping (Self.Element) -> SafeSignal<Swift.Bool>) -> Signal<Self.Element, Self.Error>
  public func first() -> Signal<Self.Element, Self.Error>
  public func ignoreOutput() -> Signal<Self.Element, Self.Error>
  public func ignoreTerminal() -> Signal<Self.Element, Self.Error>
  public func last() -> Signal<Self.Element, Self.Error>
  public func pausable<O>(by other: O) -> Signal<Self.Element, Self.Error> where O : SignalProtocol, O.Element == Swift.Bool
  public func sample(interval: Swift.Double, on queue: Dispatch.DispatchQueue = DispatchQueue(label: "com.mbark.signal.sample")) -> Signal<Self.Element, Self.Error>
  public func dropFirst(_ count: Swift.Int) -> Signal<Self.Element, Self.Error>
  public func dropLast(_ count: Swift.Int) -> Signal<Self.Element, Self.Error>
  public func dropFirst(for seconds: Swift.Double) -> Signal<Self.Element, Self.Error>
  public func prefix(maxLength: Swift.Int) -> Signal<Self.Element, Self.Error>
  public func suffix(maxLength: Swift.Int) -> Signal<Self.Element, Self.Error>
  public func prefix(while shouldContinue: @escaping (Self.Element) -> Swift.Bool, inclusive: Swift.Bool = false) -> Signal<Self.Element, Self.Error>
  public func prefix<S>(untilOutputFrom signal: S) -> Signal<Self.Element, Self.Error> where S : SignalProtocol
  public func throttle(for seconds: Swift.Double) -> Signal<Self.Element, Self.Error>
}
extension SignalProtocol where Self.Element : Swift.Equatable {
  public func removeDuplicates() -> Signal<Self.Element, Self.Error>
}
extension SignalProtocol {
  public func compactMap<NewWrapped>(_ transform: @escaping (Self.Element) -> NewWrapped?) -> Signal<NewWrapped, Self.Error>
}
extension SignalProtocol where Self.Element : OptionalProtocol {
  public func mapWrapped<NewWrapped>(_ transform: @escaping (Self.Element.Wrapped) -> NewWrapped) -> Signal<NewWrapped?, Self.Error>
  public func replaceNils(with replacement: Self.Element.Wrapped) -> Signal<Self.Element.Wrapped, Self.Error>
  public func ignoreNils() -> Signal<Self.Element.Wrapped, Self.Error>
}
public protocol OptionalProtocol {
  associatedtype Wrapped
  var _unbox: Swift.Optional<Self.Wrapped> { get }
  init(nilLiteral: ())
  init(_ some: Self.Wrapped)
}
extension Optional : OptionalProtocol {
  public var _unbox: Swift.Optional<Wrapped> {
    get
  }
}
public protocol Disposable : Cancellable {
  func dispose()
  var isDisposed: Swift.Bool { get }
}
extension Disposable {
  public func cancel()
}
public struct NonDisposable : Disposable {
  public static let instance: NonDisposable
  public func dispose()
  public var isDisposed: Swift.Bool {
    get
  }
}
final public class SimpleDisposable : Disposable {
  public init(isDisposed: Swift.Bool = false)
  final public var isDisposed: Swift.Bool {
    get
    set
  }
  final public func dispose()
  @objc deinit
}
final public class BlockDisposable : Disposable {
  public init(_ handler: @escaping () -> Swift.Void)
  final public var isDisposed: Swift.Bool {
    get
  }
  final public func dispose()
  @objc deinit
}
final public class DeinitDisposable : Disposable {
  public init(disposable: Disposable)
  @objc deinit
  final public var otherDisposable: Disposable? {
    get
    set
  }
  final public var isDisposed: Swift.Bool {
    get
  }
  final public func dispose()
}
final public class CompositeDisposable : Disposable {
  public init()
  public init(_ disposables: [Disposable])
  final public var isDisposed: Swift.Bool {
    get
  }
  public static func += (left: CompositeDisposable, right: Disposable)
  final public func add(disposable: Disposable)
  final public func dispose()
  @objc deinit
}
final public class SerialDisposable : Disposable {
  public init(otherDisposable: Disposable?)
  final public var isDisposed: Swift.Bool {
    get
  }
  final public var otherDisposable: Disposable? {
    get
    set
  }
  final public func dispose()
  @objc deinit
}
public protocol DisposeBagProtocol : Disposable {
  func add(disposable: Disposable)
}
final public class DisposeBag : DisposeBagProtocol {
  public init()
  @objc deinit
  final public var isDisposed: Swift.Bool {
    get
  }
  final public var deallocated: SafeSignal<Swift.Void> {
    get
  }
  public static func += (left: DisposeBag, right: Disposable)
  public static func += (left: DisposeBag, right: [Disposable])
  final public func add(disposable: Disposable)
  final public func add(disposables: [Disposable])
  final public func dispose()
}
final public class AnyCancellable : Disposable {
  public init(_ handler: @escaping () -> Swift.Void)
  @objc deinit
  final public var isDisposed: Swift.Bool {
    get
  }
  final public func dispose()
}
extension AnyCancellable : Swift.Hashable {
  public static func == (lhs: AnyCancellable, rhs: AnyCancellable) -> Swift.Bool
  final public func hash(into hasher: inout Swift.Hasher)
  final public var hashValue: Swift.Int {
    get
  }
}
extension AnyCancellable {
  convenience public init(_ disposable: Disposable)
  final public func store<C>(in collection: inout C) where C : Swift.RangeReplaceableCollection, C.Element == AnyCancellable
  final public func store(in set: inout Swift.Set<AnyCancellable>)
}
extension Disposable {
  public func dispose(in disposeBag: DisposeBagProtocol)
  public func store(in disposeBag: DisposeBagProtocol)
  public func store<C>(in collection: inout C) where C : Swift.RangeReplaceableCollection, C.Element == AnyCancellable
  public func store(in set: inout Swift.Set<AnyCancellable>)
}
public func combineLatest<A, B, Result>(_ a: A, _ b: B, combine: @escaping (A.Element, B.Element) -> Result) -> Signal<Result, A.Error> where A : SignalProtocol, B : SignalProtocol, A.Error == B.Error
public func combineLatest<A, B, C, Result>(_ a: A, _ b: B, _ c: C, combine: @escaping (A.Element, B.Element, C.Element) -> Result) -> Signal<Result, A.Error> where A : SignalProtocol, B : SignalProtocol, C : SignalProtocol, A.Error == B.Error, B.Error == C.Error
public func combineLatest<A, B, C, D, Result>(_ a: A, _ b: B, _ c: C, _ d: D, combine: @escaping (A.Element, B.Element, C.Element, D.Element) -> Result) -> Signal<Result, A.Error> where A : SignalProtocol, B : SignalProtocol, C : SignalProtocol, D : SignalProtocol, A.Error == B.Error, B.Error == C.Error, C.Error == D.Error
public func combineLatest<A, B, C, D, E, Result>(_ a: A, _ b: B, _ c: C, _ d: D, _ e: E, combine: @escaping (A.Element, B.Element, C.Element, D.Element, E.Element) -> Result) -> Signal<Result, A.Error> where A : SignalProtocol, B : SignalProtocol, C : SignalProtocol, D : SignalProtocol, E : SignalProtocol, A.Error == B.Error, B.Error == C.Error, C.Error == D.Error, D.Error == E.Error
public func combineLatest<A, B, C, D, E, F, Result>(_ a: A, _ b: B, _ c: C, _ d: D, _ e: E, _ f: F, combine: @escaping (A.Element, B.Element, C.Element, D.Element, E.Element, F.Element) -> Result) -> Signal<Result, A.Error> where A : SignalProtocol, B : SignalProtocol, C : SignalProtocol, D : SignalProtocol, E : SignalProtocol, F : SignalProtocol, A.Error == B.Error, B.Error == C.Error, C.Error == D.Error, D.Error == E.Error, E.Error == F.Error
public func combineLatest<A, B>(_ a: A, _ b: B) -> Signal<(A.Element, B.Element), A.Error> where A : SignalProtocol, B : SignalProtocol, A.Error == B.Error
public func combineLatest<A, B, C>(_ a: A, _ b: B, _ c: C) -> Signal<(A.Element, B.Element, C.Element), A.Error> where A : SignalProtocol, B : SignalProtocol, C : SignalProtocol, A.Error == B.Error, B.Error == C.Error
public func combineLatest<A, B, C, D>(_ a: A, _ b: B, _ c: C, _ d: D) -> Signal<(A.Element, B.Element, C.Element, D.Element), A.Error> where A : SignalProtocol, B : SignalProtocol, C : SignalProtocol, D : SignalProtocol, A.Error == B.Error, B.Error == C.Error, C.Error == D.Error
public func combineLatest<A, B, C, D, E>(_ a: A, _ b: B, _ c: C, _ d: D, _ e: E) -> Signal<(A.Element, B.Element, C.Element, D.Element, E.Element), A.Error> where A : SignalProtocol, B : SignalProtocol, C : SignalProtocol, D : SignalProtocol, E : SignalProtocol, A.Error == B.Error, B.Error == C.Error, C.Error == D.Error, D.Error == E.Error
public func combineLatest<A, B, C, D, E, F>(_ a: A, _ b: B, _ c: C, _ d: D, _ e: E, _ f: F) -> Signal<(A.Element, B.Element, C.Element, D.Element, E.Element, F.Element), A.Error> where A : SignalProtocol, B : SignalProtocol, C : SignalProtocol, D : SignalProtocol, E : SignalProtocol, F : SignalProtocol, A.Error == B.Error, B.Error == C.Error, C.Error == D.Error, D.Error == E.Error, E.Error == F.Error
public func zip<A, B, Result>(_ a: A, _ b: B, combine: @escaping (A.Element, B.Element) -> Result) -> Signal<Result, A.Error> where A : SignalProtocol, B : SignalProtocol, A.Error == B.Error
public func zip<A, B, C, Result>(_ a: A, _ b: B, _ c: C, combine: @escaping (A.Element, B.Element, C.Element) -> Result) -> Signal<Result, A.Error> where A : SignalProtocol, B : SignalProtocol, C : SignalProtocol, A.Error == B.Error, B.Error == C.Error
public func zip<A, B, C, D, Result>(_ a: A, _ b: B, _ c: C, _ d: D, combine: @escaping (A.Element, B.Element, C.Element, D.Element) -> Result) -> Signal<Result, A.Error> where A : SignalProtocol, B : SignalProtocol, C : SignalProtocol, D : SignalProtocol, A.Error == B.Error, B.Error == C.Error, C.Error == D.Error
public func zip<A, B, C, D, E, Result>(_ a: A, _ b: B, _ c: C, _ d: D, _ e: E, combine: @escaping (A.Element, B.Element, C.Element, D.Element, E.Element) -> Result) -> Signal<Result, A.Error> where A : SignalProtocol, B : SignalProtocol, C : SignalProtocol, D : SignalProtocol, E : SignalProtocol, A.Error == B.Error, B.Error == C.Error, C.Error == D.Error, D.Error == E.Error
public func zip<A, B, C, D, E, F, Result>(_ a: A, _ b: B, _ c: C, _ d: D, _ e: E, _ f: F, combine: @escaping (A.Element, B.Element, C.Element, D.Element, E.Element, F.Element) -> Result) -> Signal<Result, A.Error> where A : SignalProtocol, B : SignalProtocol, C : SignalProtocol, D : SignalProtocol, E : SignalProtocol, F : SignalProtocol, A.Error == B.Error, B.Error == C.Error, C.Error == D.Error, D.Error == E.Error, E.Error == F.Error
public func zip<A, B>(_ a: A, _ b: B) -> Signal<(A.Element, B.Element), A.Error> where A : SignalProtocol, B : SignalProtocol, A.Error == B.Error
public func zip<A, B, C>(_ a: A, _ b: B, _ c: C) -> Signal<(A.Element, B.Element, C.Element), A.Error> where A : SignalProtocol, B : SignalProtocol, C : SignalProtocol, A.Error == B.Error, B.Error == C.Error
public func zip<A, B, C, D>(_ a: A, _ b: B, _ c: C, _ d: D) -> Signal<(A.Element, B.Element, C.Element, D.Element), A.Error> where A : SignalProtocol, B : SignalProtocol, C : SignalProtocol, D : SignalProtocol, A.Error == B.Error, B.Error == C.Error, C.Error == D.Error
public func zip<A, B, C, D, E>(_ a: A, _ b: B, _ c: C, _ d: D, _ e: E) -> Signal<(A.Element, B.Element, C.Element, D.Element, E.Element), A.Error> where A : SignalProtocol, B : SignalProtocol, C : SignalProtocol, D : SignalProtocol, E : SignalProtocol, A.Error == B.Error, B.Error == C.Error, C.Error == D.Error, D.Error == E.Error
public func zip<A, B, C, D, E, F>(_ a: A, _ b: B, _ c: C, _ d: D, _ e: E, _ f: F) -> Signal<(A.Element, B.Element, C.Element, D.Element, E.Element, F.Element), A.Error> where A : SignalProtocol, B : SignalProtocol, C : SignalProtocol, D : SignalProtocol, E : SignalProtocol, F : SignalProtocol, A.Error == B.Error, B.Error == C.Error, C.Error == D.Error, D.Error == E.Error, E.Error == F.Error
public func merge<A, B>(_ a: A, _ b: B) -> Signal<A.Element, A.Error> where A : SignalProtocol, B : SignalProtocol, A.Element == B.Element, A.Error == B.Error
public func merge<A, B, C>(_ a: A, _ b: B, _ c: C) -> Signal<A.Element, A.Error> where A : SignalProtocol, B : SignalProtocol, C : SignalProtocol, A.Element == B.Element, A.Error == B.Error, B.Element == C.Element, B.Error == C.Error
public func merge<A, B, C, D>(_ a: A, _ b: B, _ c: C, _ d: D) -> Signal<A.Element, A.Error> where A : SignalProtocol, B : SignalProtocol, C : SignalProtocol, D : SignalProtocol, A.Element == B.Element, A.Error == B.Error, B.Element == C.Element, B.Error == C.Error, C.Element == D.Element, C.Error == D.Error
public func merge<A, B, C, D, E>(_ a: A, _ b: B, _ c: C, _ d: D, _ e: E) -> Signal<A.Element, A.Error> where A : SignalProtocol, B : SignalProtocol, C : SignalProtocol, D : SignalProtocol, E : SignalProtocol, A.Element == B.Element, A.Error == B.Error, B.Element == C.Element, B.Error == C.Error, C.Element == D.Element, C.Error == D.Error, D.Element == E.Element, D.Error == E.Error
public func merge<A, B, C, D, E, F>(_ a: A, _ b: B, _ c: C, _ d: D, _ e: E, _ f: F) -> Signal<A.Element, A.Error> where A : SignalProtocol, B : SignalProtocol, C : SignalProtocol, D : SignalProtocol, E : SignalProtocol, F : SignalProtocol, A.Element == B.Element, A.Error == B.Error, B.Element == C.Element, B.Error == C.Error, C.Element == D.Element, C.Error == D.Error, D.Element == E.Element, D.Error == E.Error, E.Element == F.Element, E.Error == F.Error
public func amb<A, B>(_ a: A, _ b: B) -> Signal<A.Element, A.Error> where A : SignalProtocol, B : SignalProtocol, A.Element == B.Element, A.Error == B.Error
public func amb<A, B, C>(_ a: A, _ b: B, _ c: C) -> Signal<A.Element, A.Error> where A : SignalProtocol, B : SignalProtocol, C : SignalProtocol, A.Element == B.Element, A.Error == B.Error, B.Element == C.Element, B.Error == C.Error
public func amb<A, B, C, D>(_ a: A, _ b: B, _ c: C, _ d: D) -> Signal<A.Element, A.Error> where A : SignalProtocol, B : SignalProtocol, C : SignalProtocol, D : SignalProtocol, A.Element == B.Element, A.Error == B.Error, B.Element == C.Element, B.Error == C.Error, C.Element == D.Element, C.Error == D.Error
public func amb<A, B, C, D, E>(_ a: A, _ b: B, _ c: C, _ d: D, _ e: E) -> Signal<A.Element, A.Error> where A : SignalProtocol, B : SignalProtocol, C : SignalProtocol, D : SignalProtocol, E : SignalProtocol, A.Element == B.Element, A.Error == B.Error, B.Element == C.Element, B.Error == C.Error, C.Element == D.Element, C.Error == D.Error, D.Element == E.Element, D.Error == E.Error
public func amb<A, B, C, D, E, F>(_ a: A, _ b: B, _ c: C, _ d: D, _ e: E, _ f: F) -> Signal<A.Element, A.Error> where A : SignalProtocol, B : SignalProtocol, C : SignalProtocol, D : SignalProtocol, E : SignalProtocol, F : SignalProtocol, A.Element == B.Element, A.Error == B.Error, B.Element == C.Element, B.Error == C.Error, C.Element == D.Element, C.Error == D.Error, D.Element == E.Element, D.Error == E.Error, E.Element == F.Element, E.Error == F.Error
public struct Signal<Element, Error> : SignalProtocol where Error : Swift.Error {
  public typealias Producer = (AtomicObserver<Element, Error>) -> Disposable
  public init(_ producer: @escaping Signal<Element, Error>.Producer)
  public func observe(with observer: @escaping Observer<Element, Error>) -> Disposable
}
public typealias SafeSignal<Element> = Signal<Element, Swift.Never>
extension Signal {
  public static func completed() -> Signal<Element, Error>
  public static func failed(_ error: Error) -> Signal<Element, Error>
  public static func never() -> Signal<Element, Error>
  public static func withObserver() -> (Signal<Element, Error>, AnyObserver<Element, Error>)
}
extension Signal {
  public init(just element: Element)
  public init(just element: Element, after interval: Swift.Double, queue: Dispatch.DispatchQueue = DispatchQueue(label: "com.mbark.signal.just_after"))
  public init(performing body: @escaping () -> Element)
  public init(result: Swift.Result<Element, Error>)
  public init<Other>(deferring makeSignal: @escaping () -> Other) where Element == Other.Element, Error == Other.Error, Other : SignalProtocol
  public init(evaluating body: @escaping () -> Swift.Result<Element, Error>)
  public init<S>(sequence: S) where Element == S.Element, S : Swift.Sequence
  public init<S>(sequence: S, interval: Swift.Double, queue: Dispatch.DispatchQueue = DispatchQueue(label: "com.mbark.signal.sequence")) where Element == S.Element, S : Swift.Sequence
  public init<S>(flattening signals: S, strategy: FlattenStrategy) where Element == S.Element.Element, Error == S.Element.Error, S : Swift.Sequence, S.Element : SignalProtocol
  public init<S>(combiningLatest signals: S, combine: @escaping ([S.Element.Element]) -> Element) where Error == S.Element.Error, S : Swift.Collection, S.Element : SignalProtocol
}
extension Signal where Error == Swift.Error {
  public init(catching body: @escaping () throws -> Element)
}
public protocol Subscription : Cancellable {
  func request(_ demand: Subscribers.Demand)
}
extension MustacheNode {
  public func render(object o: Any?, cb: (Swift.String) -> Swift.Void)
  public func render(object o: Any?) -> Swift.String
  public func render(nodes nl: [MustacheNode], inContext ctx: MustacheRenderingContext)
  public func render(inContext ctx: MustacheRenderingContext, cb: (Swift.String) -> Swift.Void)
  public func render(inContext ctx: MustacheRenderingContext)
  public func render(lambda cb: (Swift.String, (Swift.String) -> Swift.String) -> Swift.String, nodes nl: [MustacheNode], inContext ctx: MustacheRenderingContext)
}
extension MustacheNode {
  public func render(section tag: Swift.String, nodes: [MustacheNode], inContext ctx: MustacheRenderingContext)
}
extension EffectsCornerRadius : Swift.Equatable {
  public static func == (lhs: EffectsCornerRadius, rhs: EffectsCornerRadius) -> Swift.Bool
}
extension EffectsCornerRadius : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public class MbarkPurchaseActionHandler : MbarkHandler {
  public typealias Handler = (Swift.String) -> Swift.Void
  public var finish: ((Swift.Bool) -> Swift.Void)?
  public init(id: Swift.String, handler: @escaping MbarkPurchaseActionHandler.Handler)
  final public let id: Swift.String
  final public let handle: MbarkPurchaseActionHandler.Handler
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
extension MbarkPurchaseActionHandler : Swift.Equatable {
  public static func == (lhs: MbarkPurchaseActionHandler, rhs: MbarkPurchaseActionHandler) -> Swift.Bool
}
extension UIWindow {
  public var visibleViewController: UIKit.UIViewController? {
    get
  }
  public static func visibleViewController(from viewController: UIKit.UIViewController?) -> UIKit.UIViewController?
}
extension EffectsAlphaTypeHandlingRule {
  convenience public init(acceptableAlphaTypes: [EffectsAlphaType], outputAlphaType: EffectsAlphaType)
  convenience public init(acceptableAlphaTypes: [EffectsAlphaType], _ handler: @escaping ([EffectsAlphaType]) -> EffectsAlphaType)
  convenience public init(_ handler: @escaping ([EffectsAlphaType]) -> EffectsAlphaType)
  public var acceptableAlphaTypes: [EffectsAlphaType] {
    get
  }
  public func outputAlphaType(forInputAlphaTypes inputAlphaTypes: [EffectsAlphaType]) -> EffectsAlphaType
}
extension EffectsAlphaType : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension MustacheRenderingContext {
  public func escape(string s: Swift.String) -> Swift.String
}
public struct ExecutionContext {
  public init(_ context: @escaping (@escaping () -> Swift.Void) -> Swift.Void)
  public static var immediate: ExecutionContext {
    get
  }
  public static var immediateOnMain: ExecutionContext {
    get
  }
  public static var main: ExecutionContext {
    get
  }
  public let context: (@escaping () -> Swift.Void) -> Swift.Void
  @available(macOS 10.10, *)
  public static func global(qos: Dispatch.DispatchQoS.QoSClass = .default) -> ExecutionContext
  public static func nonRecursive() -> ExecutionContext
  public func execute(_ block: @escaping () -> Swift.Void)
}
extension DispatchQueue {
  public var context: ExecutionContext {
    get
  }
  @available(*, deprecated, message: "Please use asyncAfter(deadline:execute:)")
  public func after(when interval: Swift.Double, block: @escaping () -> Swift.Void)
  public func disposableAfter(when interval: Swift.Double, block: @escaping () -> Swift.Void) -> Disposable
}
extension EffectsContext {
  public func startTaskToCreateCGImage(from image: EffectsImage, colorSpace: CoreGraphics.CGColorSpace? = nil, completion: ((EffectsRenderTask) -> Swift.Void)? = nil) throws -> (image: CoreGraphics.CGImage, task: EffectsRenderTask)
}
@_hasMissingDesignatedInitializers public class MbarkInstance : Swift.CustomDebugStringConvertible {
  @objc deinit
  public var actionHandlers: Swift.Set<MbarkActionHandler> {
    get
  }
  public var purchaseActionHandler: MbarkPurchaseActionHandler? {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  public func trackOnce(eventType: MbarkEventType, step: Swift.String? = nil, component: Swift.String? = nil, data: MbarkEventData? = nil)
  public func track(eventType: MbarkEventType, step: Swift.String? = nil, component: Swift.String? = nil, data: MbarkEventData? = nil)
}
extension EffectsCropRegion {
  public static func pixel(_ rect: CoreGraphics.CGRect) -> EffectsCropRegion
  public static func fractional(_ rect: CoreGraphics.CGRect) -> EffectsCropRegion
}
public enum AttributedMustacheNode : Swift.Equatable {
  case empty
  case global([AttributedMustacheNode])
  case text(Foundation.NSAttributedString)
  case section(Swift.String, [AttributedMustacheNode])
  case invertedSection(Swift.String, [AttributedMustacheNode])
  case tag(Foundation.NSAttributedString)
  case unescapedTag(Foundation.NSAttributedString)
  case partial(Swift.String)
  public static func == (a: AttributedMustacheNode, b: AttributedMustacheNode) -> Swift.Bool
}
extension AttributedMustacheNode {
  public var asMustacheString: Swift.String {
    get
  }
  public var asMustacheAttributedString: Foundation.NSAttributedString {
    get
  }
}
extension AttributedMustacheNode {
  public func append(toString s: inout Swift.String)
  public func append(toAttributedString s: Foundation.NSMutableAttributedString)
}
extension Sequence where Self.Element == AttributedMustacheNode {
  public var asMustacheString: Swift.String {
    get
  }
  public var asMustacheAttributedString: Foundation.NSAttributedString {
    get
  }
}
extension AttributedMustacheNode {
  public var hasKeys: Swift.Bool {
    get
  }
  public var keys: Swift.Set<Swift.String> {
    get
  }
}
extension Sequence where Self.Element == AttributedMustacheNode {
  public var keys: Swift.Set<Swift.String> {
    get
  }
}
extension Collection where Self.Element == AttributedMustacheNode {
  public var keys: Swift.Set<Swift.String> {
    get
  }
}
public enum Subscribers {
  public enum Completion<Failure> where Failure : Swift.Error {
    case finished
    case failure(Failure)
  }
}
extension EffectsDataBuffer {
  convenience public init?<T>(values: [T], options: Metal.MTLResourceOptions = [])
  public func unsafeAccess<ReturnType, BufferContentType>(_ block: (Swift.UnsafeMutableBufferPointer<BufferContentType>) throws -> ReturnType) rethrows -> ReturnType
}
public typealias MustacheRenderingFunction = (Swift.String, (Swift.String) -> Swift.String) -> Swift.String
public typealias MustacheSimpleRenderingFunction = (Swift.String) -> Swift.String
public protocol MustacheRenderingContext {
  var string: Swift.String { get }
  func append(string s: Swift.String)
  var cursor: Any? { get }
  func enter(scope ctx: Any?)
  func leave()
  func value(forTag tag: Swift.String) -> Any?
  func newLambdaContext() -> MustacheRenderingContext
  func retrievePartial(name n: Swift.String) -> MustacheNode?
}
extension MustacheRenderingContext {
  public func value(forTag tag: Swift.String) -> Any?
  public func retrievePartial(name n: Swift.String) -> MustacheNode?
}
open class MustacheDefaultRenderingContext : MustacheRenderingContext {
  public var string: Swift.String
  public var stack: [Any?]
  public init(_ root: Any?)
  public init(context: MustacheDefaultRenderingContext)
  public func append(string s: Swift.String)
  public func enter(scope ctx: Any?)
  public func leave()
  public var cursor: Any? {
    get
  }
  open func value(forTag tag: Swift.String) -> Any?
  open func newLambdaContext() -> MustacheRenderingContext
  open func retrievePartial(name n: Swift.String) -> MustacheNode?
  @objc deinit
}
extension SignalProtocol {
  public func map<U>(_ transform: @escaping (Self.Element) -> U) -> Signal<U, Self.Error>
  public func flatMap<O>(_ strategy: FlattenStrategy, _ transform: @escaping (Self.Element) -> O) -> Signal<O.Element, Self.Error> where O : SignalProtocol, Self.Error == O.Error
  public func flatMapConcat<O>(_ transform: @escaping (Self.Element) -> O) -> Signal<O.Element, Self.Error> where O : SignalProtocol, Self.Error == O.Error
  public func flatMapLatest<O>(_ transform: @escaping (Self.Element) -> O) -> Signal<O.Element, Self.Error> where O : SignalProtocol, Self.Error == O.Error
  public func flatMapMerge<O>(_ transform: @escaping (Self.Element) -> O) -> Signal<O.Element, Self.Error> where O : SignalProtocol, Self.Error == O.Error
  public func flatMapError<S>(_ recover: @escaping (Self.Error) -> S) -> Signal<Self.Element, S.Error> where S : SignalProtocol, Self.Element == S.Element
}
extension SignalProtocol where Self.Error == Swift.Error {
  public func map<U>(_ transform: @escaping (Self.Element) throws -> U) -> Signal<U, Self.Error>
}
public enum FlattenStrategy {
  case concat
  case latest
  case merge
  public static func == (a: FlattenStrategy, b: FlattenStrategy) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension SignalProtocol where Self.Element : SignalProtocol, Self.Error == Self.Element.Error {
  public typealias InnerElement = Self.Element.Element
  public func flatten(_ strategy: FlattenStrategy) -> Signal<Self.InnerElement, Self.Error>
  public func merge() -> Signal<Self.InnerElement, Self.Error>
  public func switchToLatest() -> Signal<Self.InnerElement, Self.Error>
  public func concat() -> Signal<Self.InnerElement, Self.Error>
}
extension SignalProtocol where Self.Error == Swift.Never {
  public func flatMap<O>(_ strategy: FlattenStrategy, _ transform: @escaping (Self.Element) -> O) -> Signal<O.Element, O.Error> where O : SignalProtocol
  public func flatMapConcat<O>(_ transform: @escaping (Self.Element) -> O) -> Signal<O.Element, O.Error> where O : SignalProtocol
  public func flatMapLatest<O>(_ transform: @escaping (Self.Element) -> O) -> Signal<O.Element, O.Error> where O : SignalProtocol
  public func flatMapMerge<O>(_ transform: @escaping (Self.Element) -> O) -> Signal<O.Element, O.Error> where O : SignalProtocol
}
extension SignalProtocol where Self.Element : SignalProtocol, Self.Error == Swift.Never {
  public func flatten(_ strategy: FlattenStrategy) -> Signal<Self.Element.Element, Self.Element.Error>
}
extension EffectsColorMatrix : Swift.Equatable {
  public static func == (lhs: EffectsColorMatrix, rhs: EffectsColorMatrix) -> Swift.Bool
}
extension Subscribers {
  public struct Demand : Swift.Equatable, Swift.Hashable {
    public let value: Swift.Int
    public static let unlimited: Subscribers.Demand
    @available(*, unavailable, message: "Not supported yet.")
    public static func max(_ value: Swift.Int) -> Subscribers.Demand
    public static func == (a: Subscribers.Demand, b: Subscribers.Demand) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
}
public typealias CGPoint = CoreGraphics.CGPoint
public typealias Observer<Element, Error> = (Signal<Element, Error>.Event) -> Swift.Void where Error : Swift.Error
public typealias SafeObserver<Element> = (Signal<Element, Swift.Never>.Event) -> Swift.Void
public protocol ObserverProtocol {
  associatedtype Element
  associatedtype Error : Swift.Error
  func on(_ event: Signal<Self.Element, Self.Error>.Event)
}
public struct AnyObserver<Element, Error> : ObserverProtocol where Error : Swift.Error {
  public let observer: Observer<Element, Error>
  public init(observer: @escaping Observer<Element, Error>)
  public func on(_ event: Signal<Element, Error>.Event)
}
final public class AtomicObserver<Element, Error> : ObserverProtocol, Disposable where Error : Swift.Error {
  public init(_ observer: @escaping Observer<Element, Error>)
  @available(*, deprecated, message: "Will be remove in favour of `init(_:)`. AtomicObserver is a Disposable itself now.")
  convenience public init(disposable: Disposable, observer: @escaping Observer<Element, Error>)
  final public var isDisposed: Swift.Bool {
    get
  }
  final public func on(_ event: Signal<Element, Error>.Event)
  final public func attach(_ producer: (AtomicObserver<Element, Error>) -> Disposable)
  final public func dispose()
  @objc deinit
}
extension ObserverProtocol {
  public func receive(_ element: Self.Element)
  public func receive(completion: Subscribers.Completion<Self.Error>)
  public func receive(lastElement element: Self.Element)
  public func toObserver() -> Observer<Self.Element, Self.Error>
}
extension ObserverProtocol where Self.Element == Swift.Void {
  public func receive()
}
final public class EffectsCrossZoomTransition {
  @discardableResult
  public init(from image: EffectsImage, to targetImage: EffectsImage, options: EffectsCrossZoomTransition.Options, updater: @escaping (EffectsImage) -> Swift.Void, completion: ((Swift.Bool) -> Swift.Void)?)
  @objc @_inheritsConvenienceInitializers final public class Filter : ObjectiveC.NSObject, EffectsFilter {
    @objc final public var outputPixelFormat: Metal.MTLPixelFormat
    final public var inputImage: EffectsImage?
    final public var inputTargetImage: EffectsImage?
    final public var intensity: Swift.Float
    final public var progress: Swift.Float
    @objc final public var outputImage: EffectsImage? {
      @objc get
    }
    @objc override dynamic public init()
    @objc deinit
  }
  public struct Options {
    public var intensity: Swift.Float
    public var duration: Swift.Double
    public var timingFunction: (Swift.Float) -> Swift.Float
    public init()
  }
  final public func cancel()
  @objc deinit
}
final public class CGCrossZoomTransition {
  @discardableResult
  public init(from image: CoreGraphics.CGImage, to targetImage: CoreGraphics.CGImage, options: EffectsCrossZoomTransition.Options, updater: @escaping (CoreGraphics.CGImage) -> Swift.Void, completion: ((Swift.Bool) -> Swift.Void)?) throws
  public enum Error : Swift.Error {
    case noMetalDeviceFound
    public static func == (a: CGCrossZoomTransition.Error, b: CGCrossZoomTransition.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  @discardableResult
  public static func transition(from image: CoreGraphics.CGImage, to targetImage: CoreGraphics.CGImage, options: EffectsCrossZoomTransition.Options, updater: @escaping (CoreGraphics.CGImage) -> Swift.Void, completion: ((Swift.Bool) -> Swift.Void)?) throws -> CGCrossZoomTransition
  final public func cancel()
  @objc deinit
}
@objc final public class ViewControllerCrossZoomTransition : ObjectiveC.NSObject, UIKit.UIViewControllerAnimatedTransitioning {
  public init(options: EffectsCrossZoomTransition.Options)
  @objc final public func transitionDuration(using transitionContext: UIKit.UIViewControllerContextTransitioning?) -> Foundation.TimeInterval
  @objc final public func animateTransition(using transitionContext: UIKit.UIViewControllerContextTransitioning)
  @objc override dynamic public init()
  @objc deinit
}
public class LoadingProperty<LoadingValue, LoadingError> : PropertyProtocol, SignalProtocol, DisposeBagProvider where LoadingError : Swift.Error {
  public init(_ signalProducer: @escaping () -> LoadingSignal<LoadingValue, LoadingError>)
  public var bag: DisposeBag {
    get
  }
  public var loadingState: LoadingState<LoadingValue, LoadingError> {
    get
  }
  public var value: LoadingValue? {
    get
    set
  }
  public func reload(silently: Swift.Bool = true) -> LoadingSignal<LoadingValue, LoadingError>
  public func observe(with observer: @escaping (Signal<LoadingState<LoadingValue, LoadingError>, Swift.Never>.Event) -> Swift.Void) -> Disposable
  public typealias Element = LoadingState<LoadingValue, LoadingError>
  public typealias Error = Swift.Never
  public typealias ProperyElement = LoadingValue?
  @objc deinit
}
extension SignalProtocol {
  public func reloading<LoadingValue>(_ property: LoadingProperty<LoadingValue, Self.Error>) -> Signal<Self.Element, Self.Error>
}
extension SignalProtocol where Self.Element : LoadingStateProtocol, Self.Error == Swift.Never {
  public func reloading<V>(_ property: LoadingProperty<V, Self.LoadingError>, strategy: FlattenStrategy = .latest) -> LoadingSignal<Self.LoadingValue, Self.LoadingError>
}
extension UIButton {
  public func setMbarkId(_ id: Swift.String?, trackEvents: Swift.Bool = true)
}
public enum MustacheNode : Swift.Equatable {
  case empty
  case global([MustacheNode])
  case text(Swift.String)
  case section(Swift.String, [MustacheNode])
  case invertedSection(Swift.String, [MustacheNode])
  case tag(Swift.String)
  case unescapedTag(Swift.String)
  case partial(Swift.String)
  public static func == (a: MustacheNode, b: MustacheNode) -> Swift.Bool
}
extension MustacheNode {
  public var asMustacheString: Swift.String {
    get
  }
}
extension MustacheNode {
  public func append(toString s: inout Swift.String)
}
extension Sequence where Self.Element == MustacheNode {
  public var asMustacheString: Swift.String {
    get
  }
}
extension MustacheNode {
  public var hasKeys: Swift.Bool {
    get
  }
  public var keys: Swift.Set<Swift.String> {
    get
  }
}
extension Sequence where Self.Element == MustacheNode {
  public var keys: Swift.Set<Swift.String> {
    get
  }
}
extension Collection where Self.Element == MustacheNode {
  public var keys: Swift.Set<Swift.String> {
    get
  }
}
@available(iOS 11.0, macOS 10.13, *)
public struct EffectsCoreImageKernel {
  public enum Error : Swift.Error {
    case failedToCreateCIImage
    case nilOutput
    public static func == (a: EffectsCoreImageKernel.Error, b: EffectsCoreImageKernel.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public static func image(byProcessing images: [EffectsImage], using filter: @escaping ([CoreImage.CIImage]) throws -> CoreImage.CIImage, colorSpace: CoreGraphics.CGColorSpace? = CGColorSpaceCreateDeviceRGB(), outputDimensions: EffectsTextureDimensions, outputPixelFormat: Metal.MTLPixelFormat = .unspecified, outputAlphaType: EffectsAlphaType = .nonPremultiplied) -> EffectsImage
  public static func image(byProcessing inputImage: EffectsImage, using filter: CoreImage.CIFilter, colorSpace: CoreGraphics.CGColorSpace? = CGColorSpaceCreateDeviceRGB(), outputDimensions: EffectsTextureDimensions, outputPixelFormat: Metal.MTLPixelFormat = .unspecified, outputAlphaType: EffectsAlphaType = .nonPremultiplied) -> EffectsImage
}
@available(iOS 11.0, macOS 10.13, *)
final public class EffectsCoreImageUnaryFilter : EffectsUnaryFilter {
  public init()
  @objc final public var outputPixelFormat: Metal.MTLPixelFormat
  final public var colorSpace: CoreGraphics.CGColorSpace?
  final public var filter: CoreImage.CIFilter?
  @objc final public var inputImage: EffectsImage?
  final public var outputImageSize: CoreGraphics.CGSize?
  final public var outputAlphaType: EffectsAlphaType
  @objc final public var outputImage: EffectsImage? {
    @objc get
  }
  @objc deinit
}
extension EffectsLayer.FlipOptions : Swift.Hashable {
}
extension EffectsLayer.LayoutUnit : Swift.Hashable {
}
extension EffectsLayer.LayoutUnit : Swift.CustomDebugStringConvertible, Swift.CustomStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
  public var description: Swift.String {
    get
  }
}
public class MultilayerCompositingFilter : EffectsFilter {
  public init()
  public struct Layer : Swift.Hashable, Swift.Equatable {
    public init(content: EffectsImage)
    public var content: EffectsImage
    public var contentRegion: CoreGraphics.CGRect
    public var contentFlipOptions: EffectsLayer.FlipOptions
    public var mask: EffectsMask?
    public var compositingMask: EffectsMask?
    public var layoutUnit: EffectsLayer.LayoutUnit
    public var position: CGPoint
    public var size: CoreGraphics.CGSize
    public var rotation: Swift.Float
    public var opacity: Swift.Float
    public var cornerRadius: EffectsCornerRadius
    public var cornerCurve: EffectsCornerCurve
    public var tintColor: EffectsColor
    public var blendMode: EffectsBlendMode
    public static func content(_ image: EffectsImage) -> MultilayerCompositingFilter.Layer
    public static func content(_ image: EffectsImage, modifier: (inout MultilayerCompositingFilter.Layer) -> Swift.Void) -> MultilayerCompositingFilter.Layer
    public func hash(into hasher: inout Swift.Hasher)
    public func opacity(_ value: Swift.Float) -> MultilayerCompositingFilter.Layer
    public func contentRegion(_ contentRegion: CoreGraphics.CGRect) -> MultilayerCompositingFilter.Layer
    public func contentFlipOptions(_ contentFlipOptions: EffectsLayer.FlipOptions) -> MultilayerCompositingFilter.Layer
    public func mask(_ mask: EffectsMask?) -> MultilayerCompositingFilter.Layer
    public func compositingMask(_ mask: EffectsMask?) -> MultilayerCompositingFilter.Layer
    public func frame(_ rect: CoreGraphics.CGRect, layoutUnit: EffectsLayer.LayoutUnit) -> MultilayerCompositingFilter.Layer
    public func frame(center: CGPoint, size: CoreGraphics.CGSize, layoutUnit: EffectsLayer.LayoutUnit) -> MultilayerCompositingFilter.Layer
    public func rotation(_ rotation: Swift.Float) -> MultilayerCompositingFilter.Layer
    public func tintColor(_ color: EffectsColor?) -> MultilayerCompositingFilter.Layer
    public func blendMode(_ blendMode: EffectsBlendMode) -> MultilayerCompositingFilter.Layer
    public func corner(radius: EffectsCornerRadius, curve: EffectsCornerCurve) -> MultilayerCompositingFilter.Layer
    public func cornerRadius(_ radius: EffectsCornerRadius) -> MultilayerCompositingFilter.Layer
    public func cornerRadius(_ radius: Swift.Float) -> MultilayerCompositingFilter.Layer
    public func cornerCurve(_ curve: EffectsCornerCurve) -> MultilayerCompositingFilter.Layer
    public static func == (a: MultilayerCompositingFilter.Layer, b: MultilayerCompositingFilter.Layer) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
  }
  @objc public var outputPixelFormat: Metal.MTLPixelFormat {
    @objc get
    @objc set
  }
  @objc public var outputImage: EffectsImage? {
    @objc get
  }
  public var inputBackgroundImage: EffectsImage? {
    get
    set
  }
  public var outputAlphaType: EffectsAlphaType {
    get
    set
  }
  public var layers: [MultilayerCompositingFilter.Layer] {
    get
    set
  }
  public var rasterSampleCount: Swift.Int {
    get
    set
  }
  @objc deinit
}
extension MultilayerCompositingFilter.Layer : Swift.CustomDebugStringConvertible, Swift.CustomStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
  public var description: Swift.String {
    get
  }
}
extension EffectsError : Swift.Equatable {
}
extension EffectsFunctionDescriptor {
  public static let passthroughFragment: EffectsFunctionDescriptor
  public static let passthroughVertex: EffectsFunctionDescriptor
}
extension EffectsFunctionDescriptor {
  convenience public init(name: Swift.String, constantValues: Metal.MTLFunctionConstantValues? = nil, in bundle: Foundation.Bundle)
}
extension URL {
  public static func defaultMetalLibraryURL(for bundleForClass: Swift.AnyClass) -> Foundation.URL!
  public static func defaultMetalLibraryURL(for bundle: Foundation.Bundle) -> Foundation.URL!
}
extension CGPoint : Swift.AdditiveArithmetic {
  public static func + (lhs: CGPoint, rhs: CGPoint) -> CGPoint
  public static func - (lhs: CGPoint, rhs: CGPoint) -> CGPoint
  public static func += (lhs: inout CGPoint, rhs: CGPoint)
  public static func -= (lhs: inout CGPoint, rhs: CGPoint)
}
extension SignalProtocol {
  public func buffer(size: Swift.Int) -> Signal<[Self.Element], Self.Error>
  public func collect() -> Signal<[Self.Element], Self.Error>
  public func replaceEmpty(with element: Self.Element) -> Signal<Self.Element, Self.Error>
  public func eraseType() -> Signal<Swift.Void, Self.Error>
  public func pairwise() -> Signal<(Self.Element, Self.Element), Self.Error>
  public func replaceElements<ReplacementElement>(with element: ReplacementElement) -> Signal<ReplacementElement, Self.Error>
  public func reduce<U>(_ initial: U, _ combine: @escaping (U, Self.Element) -> U) -> Signal<U, Self.Error>
  public func scan<U>(_ initial: U, _ combine: @escaping (U, Self.Element) -> U) -> Signal<U, Self.Error>
  public func prepend(_ element: Self.Element) -> Signal<Self.Element, Self.Error>
  public func append(_ element: Self.Element) -> Signal<Self.Element, Self.Error>
  public func window(ofSize size: Swift.Int) -> Signal<Signal<Self.Element, Self.Error>, Self.Error>
  public func zipPrevious() -> Signal<(Self.Element?, Self.Element), Self.Error>
}
extension Subscribers {
  final public class Sink<Input, Failure> : Subscriber, Cancellable where Failure : Swift.Error {
    public init(receiveCompletion: @escaping ((Subscribers.Completion<Failure>) -> Swift.Void), receiveValue: @escaping ((Input) -> Swift.Void))
    final public let receiveValue: (Input) -> Swift.Void
    final public let receiveCompletion: (Subscribers.Completion<Failure>) -> Swift.Void
    final public func receive(subscription: Subscription)
    final public func receive(_ value: Input) -> Subscribers.Demand
    final public func receive(completion: Subscribers.Completion<Failure>)
    final public func cancel()
    @objc deinit
  }
}
public typealias AttribMustacheRenderingFunction = (Foundation.NSAttributedString, (Foundation.NSAttributedString) -> Foundation.NSAttributedString) -> Foundation.NSAttributedString
public typealias AttribMustacheSimpleRenderingFunction = (Foundation.NSAttributedString) -> Foundation.NSAttributedString
public protocol AttributedMustacheRenderingContext {
  var attributedString: Foundation.NSMutableAttributedString { get }
  func append(_ s: Foundation.NSAttributedString)
  var cursor: Any? { get }
  func enter(scope ctx: Any?)
  func leave()
  func value(forTag tag: Swift.String) -> Any?
  func newLambdaContext() -> AttributedMustacheRenderingContext
  func retrievePartial(name n: Swift.String) -> AttributedMustacheNode?
}
extension AttributedMustacheRenderingContext {
  public func value(forTag tag: Swift.String) -> Any?
  public func retrievePartial(name n: Swift.String) -> MustacheNode?
}
open class AttribMustacheDefaultRenderingContext : AttributedMustacheRenderingContext {
  final public let attributedString: Foundation.NSMutableAttributedString
  public var stack: [Any?]
  public init(_ root: Any?)
  public init(context: AttribMustacheDefaultRenderingContext)
  public func append(_ s: Foundation.NSAttributedString)
  public func enter(scope ctx: Any?)
  public func leave()
  public var cursor: Any? {
    get
  }
  open func value(forTag tag: Swift.String) -> Any?
  open func newLambdaContext() -> AttributedMustacheRenderingContext
  open func retrievePartial(name n: Swift.String) -> AttributedMustacheNode?
  @objc deinit
}
extension SignalProtocol {
  public func materialize() -> Signal<Signal<Self.Element, Self.Error>.Event, Swift.Never>
  public func dematerialize<U, E>() -> Signal<U, E> where E == Self.Error, Self.Element == Signal<U, E>.Event
}
extension SignalProtocol where Self.Error == Swift.Never {
  public func dematerialize<U, E>() -> Signal<U, E> where E : Swift.Error, Self.Element == Signal<U, E>.Event
}
public protocol SubjectProtocol : ObserverProtocol, SignalProtocol {
}
extension SubjectProtocol {
  public func send(_ element: Self.Element)
  public func send(completion: Subscribers.Completion<Self.Error>)
  public func send(lastElement element: Self.Element)
}
extension SubjectProtocol where Self.Element == Swift.Void {
  public func send()
}
open class Subject<Element, Error> : SubjectProtocol where Error : Swift.Error {
  public init()
  open func on(_ event: Signal<Element, Error>.Event)
  open func observe(with observer: @escaping Observer<Element, Error>) -> Disposable
  public var isTerminated: Swift.Bool {
    get
  }
  final public let disposeBag: DisposeBag
  @objc deinit
}
extension Subject : BindableProtocol {
  public func bind(signal: Signal<Element, Swift.Never>) -> Disposable
}
@_inheritsConvenienceInitializers final public class PassthroughSubject<Element, Error> : Subject<Element, Error> where Error : Swift.Error {
  override public init()
  override final public func on(_ event: Signal<Element, Error>.Event)
  override final public func observe(with observer: @escaping (Signal<Element, Error>.Event) -> Swift.Void) -> Disposable
  @objc deinit
}
final public class ReplaySubject<Element, Error> : Subject<Element, Error> where Error : Swift.Error {
  public init(bufferSize: Swift.Int = Int.max)
  final public let bufferSize: Swift.Int
  override final public func on(_ event: Signal<Element, Error>.Event)
  override final public func observe(with observer: @escaping (Signal<Element, Error>.Event) -> Swift.Void) -> Disposable
  override public init()
  @objc deinit
}
public typealias SafeReplaySubject<Element> = ReplaySubject<Element, Swift.Never>
@_inheritsConvenienceInitializers final public class ReplayOneSubject<Element, Error> : Subject<Element, Error> where Error : Swift.Error {
  override public init()
  override final public func on(_ event: Signal<Element, Error>.Event)
  override final public func observe(with observer: @escaping (Signal<Element, Error>.Event) -> Swift.Void) -> Disposable
  @objc deinit
}
public typealias SafeReplayOneSubject<Element> = ReplayOneSubject<Element, Swift.Never>
final public class ReplayLoadingValueSubject<Val, LoadingError, Error> : Subject<LoadingState<Val, LoadingError>, Error> where LoadingError : Swift.Error, Error : Swift.Error {
  public init(bufferSize: Swift.Int = Int.max)
  final public let bufferSize: Swift.Int
  override final public func on(_ event: Signal<LoadingState<Val, LoadingError>, Error>.Event)
  override final public func observe(with observer: @escaping (Signal<LoadingState<Val, LoadingError>, Error>.Event) -> Swift.Void) -> Disposable
  override public init()
  @objc deinit
}
extension SignalProtocol {
  public func mapError<F>(_ transform: @escaping (Self.Error) -> F) -> Signal<Self.Element, F> where F : Swift.Error
  public func branchOutError() -> (Signal<Self.Element, Swift.Never>, Signal<Self.Error, Swift.Never>)
  public func branchOutError<F>(_ mapError: @escaping (Self.Error) -> F) -> (Signal<Self.Element, Swift.Never>, Signal<F, Swift.Never>)
  public func suppressError(logging: Swift.Bool, file: Swift.String = #file, line: Swift.Int = #line) -> Signal<Self.Element, Swift.Never>
  public func suppressAndFeedError<S>(into listener: S, logging: Swift.Bool = true, file: Swift.String = #file, line: Swift.Int = #line) -> Signal<Self.Element, Swift.Never> where S : SubjectProtocol, Self.Error == S.Element
  public func replaceError(with element: Self.Element) -> Signal<Self.Element, Swift.Never>
  public func retry(_ times: Swift.Int, if shouldRetry: @escaping (Self.Error) -> Swift.Bool = { _ in true }) -> Signal<Self.Element, Self.Error>
  public func retry<S>(when other: S, if shouldRetry: @escaping (Self.Error) -> Swift.Bool = { _ in true }) -> Signal<Self.Element, Self.Error> where S : SignalProtocol, S.Error == Swift.Never
  public func timeout(after interval: Swift.Double, with error: Self.Error, on queue: Dispatch.DispatchQueue = DispatchQueue(label: "com.mbark.signal.timeout")) -> Signal<Self.Element, Self.Error>
  public func toErrorSignal() -> Signal<Self.Error, Swift.Never>
}
extension SignalProtocol where Self.Error == Swift.Never {
  public func castError<E>() -> Signal<Self.Element, E> where E : Swift.Error
}
@_hasMissingDesignatedInitializers public class Mbark {
  public static var isActive: Swift.Bool {
    get
  }
  @discardableResult
  public static func initialize(instanceName: Swift.String = UUID().uuidString, selectedLanguage: Swift.String? = nil) -> MbarkInstance?
  @discardableResult
  public static func initialize(instanceName: Swift.String = UUID().uuidString, remoteConfigId: Swift.String, productionAPIKey: Swift.String? = nil, developmentAPIKey: Swift.String? = nil, selectedLanguage: Swift.String? = nil) -> MbarkInstance?
  public static func setMainInstance(name: Swift.String)
  public static func removeInstance(name: Swift.String)
  public static func track(eventType: MbarkEventType, step: Swift.String? = nil, component: Swift.String? = nil, data: MbarkEventData? = nil)
  public static func trackOnce(eventType: MbarkEventType, step: Swift.String? = nil, component: Swift.String? = nil, data: MbarkEventData? = nil)
  public static func trackFlowStart()
  public static func trackFlowEnd()
  public static func trackStepView(_ step: Swift.String, data: MbarkEventData? = nil)
  public static func trackAuthenticationForNewUser()
  public static func trackAuthenticationForExistingUser()
  public static func trackAccept(step: Swift.String? = nil, component: Swift.String? = nil, shouldTrackOnce: Swift.Bool = false)
  public static func trackReject(step: Swift.String? = nil, component: Swift.String? = nil, shouldTrackOnce: Swift.Bool = false)
  public static func trackTap(step: Swift.String? = nil, component: Swift.String? = nil, data: MbarkEventData? = nil)
  public static func trackInput(step: Swift.String? = nil, component: Swift.String? = nil, data: MbarkEventData? = nil)
  public static func trackAppLoading()
  public static func onboarding(startingViewId mbarkId: Swift.String, onLoaded: @escaping (Swift.Bool) -> Swift.Void) -> UIKit.UINavigationController?
  public static func mbarkViewController(forMbarkId mbarkId: Swift.String, onLoaded: @escaping (Swift.Bool) -> Swift.Void) -> MbarkViewController?
  public static func addActionHandler(_ actionHandler: MbarkActionHandler)
  public static func removeActionHandler(forId id: Swift.String)
  public static func addPurchaseActionHandler(_ purchaseActionHandler: MbarkPurchaseActionHandler)
  public static func removePurchaseActionHandler(forId id: Swift.String)
  @objc deinit
}
public enum MbarkConstants {
  public static let flushInterval: Swift.Double
  public static let remoteConfigFileName: Swift.String
  public static let urlScheme: Swift.String
}
public protocol OutputPort {
  associatedtype Object : AnyObject
  associatedtype Value
  var object: Self.Object { get }
  var keyPath: Swift.KeyPath<Self.Object, Self.Value> { get }
}
public protocol InputPort {
  associatedtype Object : AnyObject
  associatedtype Value
  var object: Self.Object { get }
  var writableKeyPath: Swift.ReferenceWritableKeyPath<Self.Object, Self.Value> { get }
}
public struct Port<Object, Value, Property> where Object : AnyObject, Property : Swift.KeyPath<Object, Value> {
  public let object: Object
}
extension Port : OutputPort {
  public var keyPath: Swift.KeyPath<Object, Value> {
    get
  }
}
extension Port : InputPort where Property : Swift.ReferenceWritableKeyPath<Object, Value> {
  public var writableKeyPath: Swift.ReferenceWritableKeyPath<Object, Value> {
    get
  }
}
public struct ProxyPortTarget {
  public let object: Swift.AnyObject
  public let keyPath: Swift.AnyKeyPath?
  public let writableKeyPath: Swift.AnyKeyPath?
  public init(object: Swift.AnyObject, keyPath: Swift.AnyKeyPath? = nil, writableKeyPath: Swift.AnyKeyPath? = nil)
}
public protocol ProxyPort {
  var target: ProxyPortTarget { get }
}
@_hasMissingDesignatedInitializers public class FilterGraph {
  @_hasMissingDesignatedInitializers public class ImageReceiver {
    @objc deinit
  }
  public typealias ImageReceiverInputPort = Port<FilterGraph.ImageReceiver, EffectsImage?, Swift.ReferenceWritableKeyPath<FilterGraph.ImageReceiver, EffectsImage?>>
  public static func makeImage<T>(input: T, builder: (T, FilterGraph.ImageReceiverInputPort) -> Swift.Void) -> EffectsImage?
  public static func connect(builder: () -> Swift.Void)
  public static func makeImage(builder: (FilterGraph.ImageReceiverInputPort) -> Swift.Void) -> EffectsImage?
  @objc deinit
}
@dynamicMemberLookup public struct FilterInputPorts<Filter> where Filter : AnyObject {
  public init(filter: Filter)
  public typealias InputKeyPath = Swift.ReferenceWritableKeyPath<Filter, EffectsImage?>
  public subscript(dynamicMember keyPath: FilterInputPorts<Filter>.InputKeyPath) -> Port<Filter, EffectsImage?, FilterInputPorts<Filter>.InputKeyPath> {
    get
  }
}
extension EffectsFilter {
  public var outputPort: Port<Self, EffectsImage?, Swift.KeyPath<Self, EffectsImage?>> {
    get
  }
  public var inputPorts: FilterInputPorts<Self> {
    get
  }
}
public struct UnaryFilterIOPort<Filter> : InputPort, OutputPort where Filter : EffectsUnaryFilter {
  public let object: Filter
  public let keyPath: Swift.KeyPath<Filter, EffectsImage?>
  public let writableKeyPath: Swift.ReferenceWritableKeyPath<Filter, EffectsImage?>
  public typealias Object = Filter
  public typealias Value = Swift.Optional<EffectsImage>
}
extension EffectsUnaryFilter {
  public var ioPort: UnaryFilterIOPort<Self> {
    get
  }
}
extension EffectsImage {
  public struct Port : OutputPort {
    public let object: EffectsImage
    public let keyPath: Swift.KeyPath<EffectsImage, EffectsImage?>
    public typealias Object = EffectsImage
    public typealias Value = Swift.Optional<EffectsImage>
  }
  public var outputPort: EffectsImage.Port {
    get
  }
}
public class PassthroughPort<Value> : InputPort, OutputPort {
  public init(_ value: Value)
  public var writableKeyPath: Swift.ReferenceWritableKeyPath<PassthroughPort<Value>, Value>
  public var keyPath: Swift.KeyPath<PassthroughPort<Value>, Value>
  public var object: PassthroughPort<Value> {
    get
  }
  public typealias Object = PassthroughPort<Value>
  @objc deinit
}
public typealias ImagePassthroughPort = PassthroughPort<EffectsImage?>
extension PassthroughPort where Value == EffectsImage? {
  convenience public init()
}
public struct AnyIOPort<Value> : InputPort, OutputPort, ProxyPort {
  public init<T>(_ port: T) where Value == T.Value, T : InputPort, T : OutputPort
  @_hasMissingDesignatedInitializers public class ObjectProxy {
    @objc deinit
  }
  public let object: AnyIOPort<Value>.ObjectProxy
  public let keyPath: Swift.KeyPath<AnyIOPort<Value>.ObjectProxy, Value>
  public let writableKeyPath: Swift.ReferenceWritableKeyPath<AnyIOPort<Value>.ObjectProxy, Value>
  public let target: ProxyPortTarget
  public typealias Object = AnyIOPort<Value>.ObjectProxy
}
extension AnyIOPort {
  public init<T>(_ filter: T) where Value == EffectsImage?, T : EffectsUnaryFilter
}
public struct AnyInputPort<Value> : InputPort, ProxyPort {
  public init<T>(_ port: T) where Value == T.Value, T : InputPort
  @_hasMissingDesignatedInitializers public class ObjectProxy {
    @objc deinit
  }
  public let object: AnyInputPort<Value>.ObjectProxy
  public let writableKeyPath: Swift.ReferenceWritableKeyPath<AnyInputPort<Value>.ObjectProxy, Value>
  public let target: ProxyPortTarget
  public typealias Object = AnyInputPort<Value>.ObjectProxy
}
extension AnyInputPort {
  public init<T>(_ filter: T) where Value == EffectsImage?, T : EffectsUnaryFilter
}
public struct AnyOutputPort<Value> : OutputPort, ProxyPort {
  public init<T>(_ port: T) where Value == T.Value, T : OutputPort
  @_hasMissingDesignatedInitializers public class ObjectProxy {
    @objc deinit
  }
  public let object: AnyOutputPort<Value>.ObjectProxy
  public let keyPath: Swift.KeyPath<AnyOutputPort<Value>.ObjectProxy, Value>
  public let target: ProxyPortTarget
  public typealias Object = AnyOutputPort<Value>.ObjectProxy
}
extension AnyOutputPort {
  public init<T>(_ filter: T) where Value == EffectsImage?, T : EffectsFilter
}
extension AnyOutputPort where Value == EffectsImage? {
  public init(_ image: EffectsImage)
}
public protocol OutputPortProvider {
  associatedtype Port : OutputPort
  var outputPort: Self.Port { get }
}
public protocol InputPortProvider {
  associatedtype Port : InputPort
  var inputPort: Self.Port { get }
}
extension EffectsImage : OutputPortProvider {
}
infix operator => : AdditionPrecedence
@discardableResult
public func => <Output, Input>(lhs: Output, rhs: Input) -> Input where Output : OutputPort, Input : InputPort, Output.Value == EffectsImage?, Input.Value == EffectsImage?
@discardableResult
public func => <Output, Input>(lhs: Output, rhs: Input) -> Input where Output : OutputPortProvider, Input : InputPort, Input.Value == EffectsImage?, Output.Port.Value == EffectsImage?
@discardableResult
public func => <Output, Input>(lhs: Output, rhs: Input) -> Input where Output : OutputPortProvider, Input : EffectsUnaryFilter, Output.Port.Value == EffectsImage?
@discardableResult
public func => <Output, Input>(lhs: Output, rhs: Input) -> Input where Output : EffectsFilter, Input : InputPort, Input.Value == EffectsImage?
@discardableResult
public func => <Output, Input>(lhs: Output, rhs: Input) -> Input where Output : EffectsFilter, Input : EffectsUnaryFilter
@discardableResult
public func => <Output, Input>(lhs: Output, rhs: Input) -> Input where Output : OutputPort, Input : EffectsUnaryFilter, Output.Value == EffectsImage?
@discardableResult
public func => <Output, Input>(lhs: Output, rhs: Input) -> Input where Output : EffectsFilter, Input : InputPortProvider, Input.Port.Value == EffectsImage?
@discardableResult
public func => <Output, Input>(lhs: Output, rhs: Input) -> Input where Output : OutputPort, Input : InputPortProvider, Output.Value == EffectsImage?, Input.Port.Value == EffectsImage?
@discardableResult
public func => <Output, Input>(lhs: Output, rhs: Input) -> Input where Output : OutputPortProvider, Input : InputPortProvider, Output.Port.Value == EffectsImage?, Input.Port.Value == EffectsImage?
@available(iOS 13.0, macOS 10.15, *)
extension FilterGraph {
  public static func makePublisher<T>(upstream: T, builder: @escaping (T.Output, FilterGraph.ImageReceiverInputPort) -> Swift.Void) -> Combine.AnyPublisher<EffectsImage?, Swift.Never> where T : Combine.Publisher, T.Failure == Swift.Never
}
extension Mustache {
  public static func parse(_ template: Foundation.NSAttributedString) -> AttributedMustacheNode
}
extension SignalProtocol {
  public func flatMap<NewElement>(_ transform: @escaping (Self.Element) -> [NewElement]) -> Signal<NewElement, Self.Error>
}
extension SignalProtocol where Self.Element : Swift.Sequence {
  public func mapElement<NewElement>(_ transform: @escaping (Self.Element.Iterator.Element) -> NewElement) -> Signal<[NewElement], Self.Error>
  public func flattenElements() -> Signal<Self.Element.Iterator.Element, Self.Error>
}
extension EffectsVideoCompositionRequestHandler.Error : Swift.Equatable {}
extension EffectsVideoCompositionRequestHandler.Error : Swift.Hashable {}
extension EffectsVideoComposition.Error : Swift.Equatable {}
extension EffectsVideoComposition.Error : Swift.Hashable {}
extension TimelaneLaneType : Swift.Equatable {}
extension TimelaneLaneType : Swift.Hashable {}
extension TimelaneLaneType : Swift.RawRepresentable {}
extension MbarkEventType : Swift.Equatable {}
extension MbarkEventType : Swift.Hashable {}
extension MbarkEventType : Swift.RawRepresentable {}
extension MbarkStepNames : Swift.Equatable {}
extension MbarkStepNames : Swift.Hashable {}
extension MbarkStepNames : Swift.RawRepresentable {}
extension AuthenticationUserType : Swift.Equatable {}
extension AuthenticationUserType : Swift.Hashable {}
extension AuthenticationUserType : Swift.RawRepresentable {}
extension EffectsSIMDArgumentEncoder.Error : Swift.Equatable {}
extension EffectsSIMDArgumentEncoder.Error : Swift.Hashable {}
extension EffectsSIMDArgumentEncoder.Error : Swift.RawRepresentable {}
extension CGImageDisplacementTransition.Error : Swift.Equatable {}
extension CGImageDisplacementTransition.Error : Swift.Hashable {}
extension FlattenStrategy : Swift.Equatable {}
extension FlattenStrategy : Swift.Hashable {}
extension CGCrossZoomTransition.Error : Swift.Equatable {}
extension CGCrossZoomTransition.Error : Swift.Hashable {}
@available(iOS 11.0, macOS 10.13, *)
extension EffectsCoreImageKernel.Error : Swift.Equatable {}
@available(iOS 11.0, macOS 10.13, *)
extension EffectsCoreImageKernel.Error : Swift.Hashable {}
